<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Электронный ресурс по учебной дисциплине Микропроцессорные системы управления</title>

    <link rel="stylesheet" type="text/css" href="../Оболочка/fancybox/jquery.fancybox-1.3.4.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../Оболочка/msu.css">

    <script type="text/javascript" src="../Оболочка/jquery.pack.js"></script>
    <script type="text/javascript" src="../Оболочка/Components.js"></script>
    <script type="text/javascript" src="../Оболочка/highlight.pack.js"></script>
    <!--<script type="text/javascript" src="../Оболочка/fancybox/jquery.min.js"></script>-->
    <script type="text/javascript" src="../Оболочка/fancybox/jquery.mousewheel-3.0.4.pack.js"></script>
    <script type="text/javascript" src="../Оболочка/fancybox/jquery.fancybox-1.3.4.pack.js"></script>

    <script type="text/javascript">
        $(document).ready(function () {
            $("a.images").fancybox({
                'transitionIn': 'fade',
                'transitionOut': 'fade',
                'titlePosition': 'inside',
                'padding': 10,
                'cyclic': true
            });
            hljs.initHighlightingOnLoad('avrasm');
        });
    </script>

</head>

<body bgcolor=#E6E6E6 topmargin=1 leftmargin=1 marginwidth=0 marginheight=0 style="max-width: 1300px;">
<div class=max>

    <a name="top"></a>
    <table border=0 width=100% cellspacing=0 cellpadding=0>
        <tr>
            <td width="190" height="91" name="link19"><a href="../index.html"><img src="../Оболочка/images/bg01.gif" alt=""></a></td>
            <td rowspan="2" background=../Оболочка/images/bg02_2.gif height="120" valign="Bottom">
                <table background=../Оболочка/images/raspor.gif border=0 cellspacing=0 cellpadding=0>
                    <tr>
                        <td width=180></td>
                        <td valign="top" height="75"><p class=h6>Микроконтроллеры</p></td>
                    </tr>
                </table>

            </td>
        </tr>
        <tr>
            <td background=../Оболочка/images/bg03.gif>
                <a href=../Программа/index.html onMouseOver="mOver(1)" onMouseOut="mOut(1)"><img src=../Оболочка/images/01a.gif border=0 width=190 height=29 alt="Рабочая программа" name="link1"></a><br>
            </td>
        </tr>
        <tr>
            <td background=../Оболочка/images/bg09.gif valign=top>

                <table border=0 cellspacing=0 cellpadding=0>
                    <tr>
                        <td background=../Оболочка/images/bg04.gif valign=top>
                            <img src=../Оболочка/images/02p.gif width=190 height=29 border=0
                                 alt="Теоретическая часть"><br></td>
                    </tr>
                    <tr>
                        <td background=../Оболочка/images/bg05.gif width=190 valign=top>
                            <img src=../Оболочка/images/02p_1.gif width=170 height=25 border=0 alt="Микроконтроллеры">
                        </td>
                    </tr>
                    <tr>
                        <td background=../Оболочка/images/bg06.gif width=190 height=36 valign=top>
                            <a href="logic.html" onMouseOver="mOver(22)" onMouseOut="mOut(22)"><img src=../Оболочка/images/02a_2.gif width=170 height=40 border=0 alt="Программируемые логические контроллеры" name="link22"></a><br>
                            <img src=../Оболочка/images/bg07.gif width=190 height=23><br></td>
                    </tr>
                    <tr>
                        <td background=../Оболочка/images/bg03.gif valign=top>
                            <a href=../Практика/part_1.html onMouseOver="mOver(3)" onMouseOut="mOut(3)"><img src=../Оболочка/images/03a.gif width=190 height=29 border=0 alt="Практическая часть 1" name="link3"></a><br>
                            <a href=../Практика/part_2.html onMouseOver="mOver(4)" onMouseOut="mOut(4)"><img src=../Оболочка/images/04a.gif width=190 height=29 border=0 alt="Практическая часть 2" name="link4"></a><br>
                            <a href=../Заочное/index.html onMouseOver="mOver(5)" onMouseOut="mOut(5)"><img src=../Оболочка/images/05a.gif width=190 height=29 border=0 alt="Заочное" name="link5"></a><br>
                            <a href=../Контроль_знаний/index.html onMouseOver="mOver(6)" onMouseOut="mOut(6)"><img src=../Оболочка/images/06a.gif width=190 height=29 border=0 alt="Контроль знаний" name="link6"></a><br>
                            <img src=../Оболочка/images/bg08.gif width=190 height=13><br>
                        </td>
                </table>
            </td>
            <td valign=top>
                <p><br></p>

                <table border=0 width=97% cellspacing=0 cellpadding=0>
                    <tr>
                        <td>


                            <table border="0" cellpadding="0" cellspacing="0" width="98%">
                                <tr>
                                    <td width=98%>
                                        <table border="0" cellpadding="0" cellspacing="0">
                                            <tr>
                                                <td bgcolor="#000000">
                                                    <img src="../Оболочка/images/raspor.gif"
                                                         height="2">
                                                </td>
                                            </tr>
                                            <tr>
                                                <td valign="center" height="30">
                                                    <span class="h1">Курс лекций "Микропроцессорные системы управления"</span>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td bgcolor="#000000">
                                                    <img src="../Оболочка/images/raspor.gif"
                                                         height="2">
                                                </td>
                                            </tr>
                                        </table>

<ul>
    <dt>
        <a class=m href="#1">Цифровые микропроцессорные системы управления</a>
    </dt>
    <ul>
        <dt><a class=m href="#1.1">Эволюция средств вычислительной техники</a></dt>
        <dt><a class=m href="#1.2">Принципы построения цифровых систем управления</a></dt>
    </ul>
    <dt><a class=m href="#2">Архитектура управляющей микроЭВМ</a></dt>
    <ul>
        <dt><a class=m href="#2.1">Основные понятия и определения</a></dt>
        <dt><a class=m href="#2.2">Архитектура микропроцессора</a></dt>
        <dt><a class=m href="#2.3">Организация шин микропроцессорных систем</a></dt>
        <dt><a class=m href="#2.4">Обработка информации в микропроцессоре</a></dt>
        <dt><a class=m href="#2.5">Управление обработкой информации</a></dt>
        <dt><a class=m href="#2.6">Архитектура 8-разрядного микропроцессора</a></dt>
        <dt><a class=m href="#2.7">Типы архитектур МП</a></dt>
        <dt><a class=m href="#2.8">CISC, RISC и WLIW архитектуры</a></dt>
        <dt><a class=m href="#2.9">Конвейерное выполнение команд</a></dt>
        <dt><a class=m href="#2.10">Блок предсказания переходов</a></dt>
        <dt><a class=m href="#2.11">Кэш память</a></dt>
    </ul>

    <dt><a class=m href="#3">Память микропроцессорных систем</a></dt>
    <ul>
        <dt><a class=m href="#3.1">Классификация запоминающих устройств</a></dt>
        <dt><a class=m href="#3.2">Оперативное запоминающее устройство</a></dt>		
        <dt><a class=m href="#3.3">Постоянное запоминающее устройство</a></dt>
        <dt><a class=m href="#3.4">Память как функциональный узел</a></dt>
        <dt><a class=m href="#3.5">Многомодульная организация памяти</a></dt>
    </ul>
	
    <dt><a class=m href="#3">Система команд микропроцессора</a></dt>
    <ul>
        <dt><a class=m href="#3.1">Классификация команд</a></dt>
        <dt><a class=m href="#3.2">Методы адресации</a></dt>
    </ul>

    <dt><a class=m href="#4">Архитектура МК AVR</a></dt>
    <ul>
        <dt><a class=m href="#4.1">Вычислительное ядро AVR</a></dt></dt>
        <dt><a class=m href="#4.2">Регистр статуса</a></dt></dt>
        <dt><a class=m href="#4.3">Организация памяти</a></dt></dt>
        <dt><a class=m href="#4.4">Методы адресации</a></dt></dt>
    </ul>

    <dt><a class=m href="#5">Система команд AVR</a></dt>
    <ul>
        <dt><a class=m href="#5.1">Команды пересылок</a></dt>
        <dt><a class=m href="#5.2">Арифметические команды</a></dt>
        <dt><a class=m href="#5.3">Команды логических операций</a></dt>
        <dt><a class=m href="#5.4">Команды операций с битами</a></dt>
        <dt><a class=m href="#5.5">Команды сдвига</a></dt>
        <dt><a class=m href="#5.6">Команды сравнения</a></dt>
        <dt><a class=m href="#5.7">Команды передачи управления</a></dt>
        <dt><a class=m href="#5.8">Команды работы с подпрограммами</a></dt>
        <dt><a class=m href="#5.9">Команды управления системой</a></dt>
    </ul>
    <dt><a class=m href="#7"> Организация ввода/вывода в микропроцессорной системе</a></dt>
    <ul>
        <dt><a class=m href="#7.1">Дискретные порты ввода/вывода (интерфейс)</a></dt>
        <dt><a class=m href="#7.2">Расширение дискретных портов вывода</a></dt>
        <dt><a class=m href="#7.3">Программно-управляемый ввод/вывод</a></dt>
        <dt><a class=m href="#7.4">Ввод/вывод в режиме прерываний</a></dt>
        <dt><a class=m href="#7.5">Ввод/вывод в режиме прямого доступа к памяти</a></dt>
        <dt><a class=m href="#7.6">Аналоговые порты ввода</a></dt>
    </ul>
    <dt><a class=m href="#8">Программная реализация алгоритмов управления</a></dt>
    <ul>
        <dt><a class=m href="#8.1">Программная реализация функций счёта и временной задержки</a></dt>
        <dt><a class=m href="#8.2">Программная генерация импульсов и функций времени</a></dt>
    </ul>
</ul><br><br>




<a name="1">
<table border=0 cellpadding=0 cellspacing=0 width=97% bgcolor=#ABB3D5>
  <tr><td bgcolor=#000000 colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
  <tr><td width="30"></td><td valign=center><span class=h>Цифровые микропроцессорные системы управления</span></td></tr>
  <tr><td bgcolor=#000000 width="25" colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
</table>
<br>

<a name="1.1"></a><p class=h3>1.1 Эволюция средств вычислительной техники</p>

<table>
<tr>
<td>

<p>История создания программируемых вычислительных устройств началась ещё в 1830 г. с идеи, предложенной английским математиком Чарльзом Бэбиджем
(Charles Babage). В 1822 году Бэббидж задумался о создании большой разностной машины, которая позволила бы заменить множество людей, занимающихся
вычислением различных астрономических, навигационных и математических таблиц. Это позволило бы сэкономить затраты на оплату труда, а также
избавиться от ошибок, связанных с человеческим фактором.</p>

<p>Практическое же появление вычислительных машин стало возможным только в XX в. в связи с развитием электроники. При этом можно проследить несколько
этапов развития ЭВМ.</p>

<p><b>Первый этап (до 1955 г.)</b> – ламповые ЭВМ, масса которых достигала 30 т, число электронных ламп – 18 тыс., потребляемая мощность – 150 кВт
(мощность, достаточная для небольшого завода), объёем памяти – 20 10-разрядных десятичных чисел, время выполнения операций: сложения – 0,0002 с,
умножения – 0,0028 с. Числа в ЭВМ вводились с помощью перфокарт и набора на переключателях, а программа задавалась соединением гнезд на специальных
наборных полях. Для ускорения процесса подготовки программ стали создавать первые языки автоматизации программирования (языки символического
кодирования).</p>

<p><b>Второй этап (до 1965 г.)</b> – появление ЭВМ, построенных на транзисторах, привело к уменьшению их габаритов, массы, энергопотребления и
стоимости, а также к увеличению надёжности и производительности. Транзистор впервые был продемонстрирован 23 декабря 1947 г. тремя сотрудниками фирмы
Bell Telephone Laboratories Джоном Бардиным, Уолтером Бременом и Уильямом Шокли. На этом этапе были созданы специальные алгоритмические языки для
инженерно-технических и экономических расчетов, а также операционные системы (комплексы служебных программ, обеспечивающих лучшее распределение
ресурсов ЭВМ при исполнении пользовательских задач). Эволюция операционных систем шла в направлении обработки пакетов заданий, а также
мультипрограммного режима обработки данных.</p>

<ul>
  <li>Элементная база – полупроводниковые элементы (транзисторы).</li>
  <li>Соединение элементов – навесной монтаж и печатные платы.</li>
  <li>Габариты – ЭВМ выполнена в виде однотипных стоек.</li>
  <li>Быстродействие – 100 .. 500 тыс. операций в секунду.</li>
  <li>Программирование – на алгоритмических языках, появление ОС, обработка пакетов заданий.</li>
  <li>Оперативная память – 2 ... 32 Кбайт.</li>
</ul>

<p>Введён принцип разделения времени и микропрограммного управления.</p>

<p><b>Третий этап (до 1970 г.)</b> – прогресс в области технологии производства интегральных микросхем (ИС) позволил повысить производительность и
снизить стоимость универсальных ЭВМ, а также создать малогабаритные, простые, дешевые и надёжные машины – мини-ЭВМ.</p>

<ul>
  <li>Элементная база – интегральные схемы.</li>
  <li>Соединение элементов – печатные платы.</li>
  <li>Быстродействие – 1-10 млн. операций в секунду.</li>
  <li>Эксплуатация – вычислительные центры, дисплейные классы, новая специальность – системный программист.</li>
  <li>Программирование – алгоритмические языки, ОС.</li>
  <li>Оперативная память – 64 Кбайт.</li>
  <li>Применяется принцип разделения времени, принцип модульности, принцип микропрограммного управления, принцип магистральности.</li>
  <li>Появление магнитных дисков, дисплеев, графопостроителей.</li>
</ul>

<p>Мини-ЭВМ первоначально предназначались для замены аппаратно-реализованных контроллеров (устройств управления) в контуре управления каким-либо
объектом, в автоматизированных системах управления технологическими процессами, системах сбора и обработки экспериментальных данных, различных
управляющих комплексах на подвижных объектах и т.д. Низкая цена серийной мини-ЭВМ, большое число серийных устройств связи с объектом управления и
хорошее программное обеспечение обусловили экономическую эффективность использования таких устройств.</p>

<p><b>Четвёртый этап (до 1978 г.)</b> – успехи в развитии электроники привели к созданию больших интегральных схем (БИС), где в одном кристалле
размещалось несколько десятков тысяч электрических элементов. Это позволило разработать более дешёвые ЭВМ, имеющие большую память и меньший цикл
выполнения команды. Но так как затраты на программирование оставались высокими, то на первый план вышла задача экономии человеческих, а не машинных
ресурсов.</p>

<p>В 1971 г. фирмой Intel был изготовлен первый микропроцессор i4004 – БИС, в котором полностью размещался простой четырёхразрядный процессор.
Появились управляющие устройства, построенные на одной или нескольких БИС, содержащих процессор, память, схемы сопряжения с датчиками и
исполнительными органами в объекте управления.</p>

<ul>
  <li>Элементная база – большие интегральные схемы (БИС);</li>
  <li>соединение элементов – печатные платы;</li>
  <li>габариты – компактные ЭВМ, ноутбуки;</li>
  <li>быстродействие – 10 .. 100 млн. операций в секунду;</li>
  <li>эксплуатация – многопроцессорные и многомашинные комплексы, любые пользователи ЭВМ;</li>
  <li>программирование – базы и банки данных;</li>
  <li>оперативная память – 2 .. 5 Мбайт;</li>
  <li>телекоммуникационная обработка данных, объединение в компьютерные сети.</li>
</ul>

<p><b>Пятый этап (c 80-х г.г.)</b> – улучшение технологии производства БИС позволило изготавливать дешёвые электронные схемы, содержащие миллионы
элементов в кристалле – схемы сверхбольшой степени интеграции (СБИС). Появилась возможность создать устройство с габаритами массового телевизора, в
котором размещались микроЭВМ, клавиатура, экран, дисковый накопитель, а также схемы сопряжения с малогабаритным печатающим устройством, измерительной
аппаратурой, другими ЭВМ и т.д.</p>

<ul>
  <li>Элементная база – дешёвые сверхбольшие интегральные схемы (СБИС);</li>
  <li>Компактные системы, в которых размещается микроЭВМ, клавиатура, экран, накопитель, а также схемы сопряжения с печатающим устройством,
    измерительной аппаратурой, другими ЭВМ и т.д.;</li>
  <li>Возможность параллельно решать на ЭВМ несколько задач;</li>
  <li>Компьютерные игры, прослушивание высококачественной музыки, просмотр фильмов. Ввод печатной, рукописной, голосовой информации, узнавание
    пользователя по голосу, перевод с одного языка на другой, способность вести диалог, выполнять команды, подаваемые голосом или
	прикосновением;</li>
  <li>Интерфейсы, управляемые непосредственно мозгом (нейроинтерфейсы).</li>
</ul>

<p>Способность вести диалог, выполнять команды, подаваемые голосом или прикосновением. Возможность параллельно решать на ЭВМ несколько задач.
Основной задачей разработчиков ЭВМ V поколения является создание искусственного интеллекта машины (возможность делать логические выводы из
представленных фактов), развитие “интеллектуализации” компьютеров – устранения барьера между человеком и компьютером. Компьютер теперь используется
и дома, это компьютерные игры, прослушивание высококачественной музыки, просмотр фильмов. Уже сейчас компьютеры способны воспринимать информацию с
рукописного или печатного текста, с бланков, с человеческого голоса, узнавать пользователя по голосу, осуществлять перевод с одного языка на другой.
Это позволяет общаться с компьютерами всем пользователям, даже тем, кто не имеет специальных знаний в этой области.</p>

<p>Наиболее широкое применение нашли микроЭВМ в гибких системах автоматизации производства и научных исследований. В настоящее время развитие идёт в
направлении как повышения вычислительной мощности компьютеров, так и создания однокристальных микроконтроллеров, ориентированных на управление
различными техническими объектами.</p>
</td>

<td valign="top" align="center">
<br>

    <table cellpadding="0" cellspacing="0">
        <tr>
            <td>
                <a rel="group1" class="images" href="images/008.jpg" title="1830 г. Английский математик Чарльз Бэбидж (Charles Babage)">
                    <img src="images/008.jpg" width=100>
                </a>
            </td>
            <td>
                <a rel="group1" class="images" href="images/009.jpg"
                   title="Одна из 6-ти демонстрационных моделей вычислительной части разностной машины Чарльза Бэббиджа, собранная после его смерти сыном Генри из деталей, найденных в лаборатории">
                    <img src="images/009.jpg" width=160>
                </a>
            </td>
        </tr>
    </table>
    <br>

    <table cellpadding=0 cellspacing=0>
        <tr>
            <td>
                <a rel="group2" class="images" href="images/010.jpg" title="Радиолампы"><img src="images/010.jpg" width=101></a>
            </td>
            <td>
                <a rel="group2" class="images" href="images/011.jpg" title="ЭВМ на радиолампах М20"><img src="images/011.jpg" width=160></a>
            </td>
        </tr>
        <tr>
            <td colspan="2">
                <a rel="group2" class="images" href="images/012.jpg" title="Перфолента"><img src="images/012.jpg" width=265></a>
            </td>
        </tr>
    </table>
    <br>

    <table cellpadding=0 cellspacing=0>
        <tr>
            <td>
                <a rel="group3" class="images" href="images/013.jpg"
                   title="23 декабря  1947 года  трое сотрудников Bell Telephone Laboratories Джон Бардин, Уолтер Бремен и Уильям  Шокли продемонстрировали транзистор">
                    <img src="images/013.jpg" width="130">
                </a>
            </td>
            <td>
                <a rel="group3" class="images" href="images/014.jpg"
                   title="Один из первых транзисторов">
                    <img src="images/014.jpg" width="130" height="146">
                </a>
            </td>
        </tr>
        <tr>
            <td>
                <a rel="group3" class="images" href="images/015.jpg"
                   title="Один из первых транзисторов">
                    <img src="images/015.jpg" width=130 height="119">
                </a>
            </td>
            <td>
                <a rel="group3" class="images" href="images/016.jpg"
                   title="Транзисторная ЭВМ БЭСМ-4 20.000 опер.в сек.">
                    <img src="images/016.jpg" width=130>
                </a>
            </td>
        </tr>
    </table>
    <br>

    <table cellpadding=0 cellspacing=0>
        <tr>
            <td>
                <a rel="group4" class="images" href="images/017.jpg"
                   title="ЭВМ на интегральных микросхемах ЕС1022. 32 разрядная, ОЗУ 4Мб">
                    <img src="images/017.jpg" width=128>
                </a>
            </td>
            <td>
                <a rel="group4" class="images" href="images/018.jpg"
                   title="Кристалл первого микропроцессора i4004">
                    <img src="images/018.jpg" width=128 height="95">
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="2">
                <a rel="group4" class="images" href="images/019.jpg"
                   title="Первый микропроцессор i4004. 4 разрядный. Использовался в микрокалькуляторах">
                    <img src="images/019.jpg" width=260>
                </a>
            </td>
        </tr>
    </table>
    <br>

    <table cellpadding=0 cellspacing=0>
        <tr>
            <td>
                <a rel="group5" class="images" href="images/020.jpg" title="Компьютер IBM">
				<img src="images/020.jpg" width=148>
                </a>
            </td>
            <td>
                <a rel="group5" class="images" href="images/021.jpg"
                   title="Стив Возняк и Стив Джобс с Apple II">
                    <img src="images/021.jpg" width=108>
                </a>
            </td>
        </tr>
        <tr>
            <td colspan="2">
                <a rel="group5" class="images" href="images/022.jpg"
                   title="Первая компьютерная мышь">
                    <img src="images/022.jpg" width=260>
                </a>
            </td>
        </tr>
    </table>
    <br>

    <table cellpadding=0 cellspacing=0>
        <tr>
            <td>
                <a rel="group6" class="images" href="images/023.jpg"
                   title="Персональный компьютер моноблок">
                    <img src="images/023.jpg" width=122 height="144">
                </a>
            </td>
            <td>
                <a rel="group6" class="images" href="images/024.jpg"
                   title="">
                    <img src="images/024.jpg" width=138
                         height="144">
                </a>
            </td>
        </tr>
    </table>
</td>

    </tr>
</table>
<br><br>




<a name="1.2"></a><p class="h3">1.2 Принципы построения цифровых систем управления</p>

<p>В современных системах управления широко применяются микропроцессоры, микроконтроллеры и другие средства вычислительной техники. Такая элементная
база позволяет унифицировать аппаратные средства, а также реализовать сложные алгоритмы управления, обеспечивающие высокие качественные
характеристики для широкого круга технических объектов.</p>

<p>Структура аппаратных средств типовой микропроцессорной системы управления приведена на рис. 1. Система содержит микроЭВМ, в состав которой входят
микропроцессор, память, а также устройства связи с объектом (интерфейсы), которые обеспечивают преобразование цифровых кодов на выходе микроЭВМ в
сигналы, воспринимаемые объектом управления, а также преобразование выходных сигналов датчиков в двоичные коды, поступающие в микроЭВМ. Такое
управляющее устройство с некоторым тактом (интервалом квантования) на основании информации о текущем состоянии объекта, а также командных сигналов
рассчитывает управляющее воздействие.</p>

<div align="center"><img src="images/025.png" title="Система управления на базе микроЭВМ"><br>
Рис. 1. Система управления на базе микроЭВМ</div>

<p>При построении систем управления на базе микропроцессоров и микроЭВМ следует учитывать следующие особенности программной реализации алгоритмов
управления:</p>

<div style="float: right; margin-left: 10px"><img src="images/026.png" title="Классификация устройств схемотехники"><br>
Рис. 2. Классификация устройств схемотехники<br></div>

<ul>
  <li>запаздывание, вносимое микроЭВМ;</li>
  <li>временное и амплитудное квантование сигналов;</li>
  <li>возможности реализации сложных логических и вычислительных процедур, обеспечивающих адаптацию к изменениям параметров объектов и возмущающих
    воздействий.</li>
</ul>

<p>Следует заметить, что цифровые системы управления на базе микропроцессоров и микроЭВМ иногда называют устройствами на основе «программируемой»
(гибкой) логики, что означает возможность их перенастройки для управления различными объектами путём изменения программы. Альтернативным методом
построения цифровых систем управления является использование «жёсткой» логики (комбинационных схем не имеющих внутренней памяти, где уровни
сигналов на выходах однозначно определяются уровнями входных сигналов в данный момент времени), при которой ядром устройства является заказная БИС,
реализующая алгоритмы управления для узкого круга объектов. Очевидно, что второй метод на сегодняшний день является более дорогостоящим, однако он
широко используется при массовом производстве устройств управления для типовых объектов либо при создании систем управления объектами специального
назначения. Для промышленного применения наиболее рациональным является первый метод, основанный на применении микропроцессоров и
микроконтроллеров.</p><br><br><br>




<a name="2"></a>
<table border=0 cellpadding=0 cellspacing=0 width=97% bgcolor=#ABB3D5>
  <tr><td bgcolor=#000000 colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
  <tr><td width="30"></td><td valign=center><span class=h>Архитектура управляющей микроЭВМ</span></td></tr>
  <tr><td bgcolor=#000000 width="25" colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
</table>
<br>

<a name="2.1"></a><p class="h3">2.1 Основные понятия и определения</p>

<p><b>Микропроцессор</b> – программно-управляемое устройство, предназначенное для обработки цифровой информации и управления процессом этой
обработки. Обычно микропроцессор (МП) состоит из одной (иногда нескольких) интегральных схем и имеет доступ к внешней памяти. Он также обеспечивает
передачу информации между компонентами ЭВМ и внешней средой. МП является основой любой микроЭВМ и производится по технологии больших интегральных
схем (БИС).</p>

<p><b>МикроЭВМ</b> – вычислительное или управляющее устройство, содержащее микропроцессор, оперативное запоминающее устройство (ОЗУ), постоянное
запоминающее устройство (ПЗУ), таймер, порты ввода/вывода, генератор тактовых импульсов, блок питания и другие элементы.</p>

<p><b>Однокристальный микроконтроллер</b> – БИС, содержащая в себе МП, ОЗУ, ПЗУ небольшого объёма, таймеры/счётчики, порты ввода/вывода, и
ориентированная на решение задач управления. Появлению микроконтроллеров способствовало совершенствование технологии производства микроэлектроники,
что позволило интегрировать на одном кристалле большинство функциональных блоков управляющей микроЭВМ. В большинстве микроконтроллеров используется
восьмиразрядное вычислительное ядро с упрощенной системой команд. Память физически и логически разделена на память программ и память данных.
Подсистема ввода/вывода микроконтроллеров часто имеет аналого-цифровые и цифроаналоговые преобразователи для возможности ввода сигналов от датчиков
и вывода сигналов на исполнительное устройство.</p>

<p><b>Цифровой процессор сигналов</b> (Digital Signal Processor, DSP) – это специализированный микроконтроллер, ориентированный на решение задач
цифровой фильтрации в режиме реального времени. Обычно DSP имеет мощное вычислительное ядро, спроектированное, однако, только для решения
узкоспециализированных задач. По этой причине сигнальные процессоры имеют сравнительно невысокую стоимость по сравнению с обычной микроЭВМ,
реализующей аналогичные функции. Применяемые, например в области телекоммуникаций DSP имеют производительность до 1,6 млрд. операций/с. С
архитектурной точки зрения такие процессоры могут представлять собой аналоговые функциональные преобразователи сигналов. Часто они выполняют функции
аналоговых схем (например производят генерацию колебаний, модуляцию, смещение, фильтрацию, кодирование и декодирование сигналов в реальном масштабе
времени и т.д., заменяя сложные схемы, состоящие из операционных усилителей, катушек индуктивности, конденсаторов и т.д.).</p>
<br><br>



<a name="2.2"></a><p class="h3">2.2 Архитектура микропроцессора</p>

<p>Особенность МП как устройства с программируемой логикой заключается в подчинённости его аппаратного состава (или структуры совокупности элементов,
составляющих МП, и связей между ними) принципу программируемости. Это означает, что функции, реализуемые МП, определяются не столько его структурой,
сколько последовательностью управляющих слов (команд), поступающих из программной памяти на входы МП. При изменении этой последовательности
изменяется и функция, выполняемая МП. Поэтому разработчик микроЭВМ при анализе функциональных возможностей МП должен учитывать не только его
структуру, но и возможности программной реализации функций.</p>

<div style="float: right; margin: 20px"><img src="images/027.png" title="Обобщённая структурная схема ЭВМ"><br>
<center>Рис. 3. Обобщённая структурная схема ЭВМ</center></div>

<p>Все ЭВМ содержат следующие функциональные блоки, имеющие свою архитектуру: процессор, состоящий из арифметико-логического устройства (АЛУ),
регистров общего назначения (РОН) и устройства управления (УУ), память (оперативная – ОЗУ и постоянная – ПЗУ), устройства ввода-вывода информации.
Устройство управления формирует управляющие сигналы для работы РОН и АЛУ, а те, в свою очередь, формируют признаки (или флаги). Объединение
функциональных блоков в ЭВМ осуществляется посредством системы шин: шины данных, по которой осуществляется обмен данными между блоками ЭВМ, шины
адреса, используемой для передачи адресов, по которым осуществляется обращение к различным устройствам ЭВМ, и шины управления для передачи
управляющих сигналов (рис. 3).</p>

<p>Связь с пользователем осуществляется с помощью пульта управления, который позволяет выполнить такие действия, как пуск ЭВМ; останов, под
действием которого прекращается поступление сигналов с генератора тактовых импульсов и процессор переходит в состояние ожидания; загрузка начального
адреса программы; её пошаговое выполнение при отладке.</p>

<p>МП можно классифицировать по нескольким признакам:</p>

<p>1. По <b>количеству БИС</b> различают однокристальные, многокристальные и многокристальные секционные микропроцессоры.</p>

<p>В однокристальном МП все его аппаратные средства реализованы в виде одной БИС, имеющей фиксированную разрядность и жёсткую систему команд.
Параметры однокристальных микропроцессоров улучшаются по мере увеличения степени интеграции элементов в кристалле и числа выводов корпуса. Однако
возможности однокристальных микропроцессоров ограничены аппаратными ресурсами кристалла и корпуса. Поэтому при разбиении его логической структуры на
функционально законченные части можно реализовать процессор в виде нескольких работающих автономно БИС с фиксированной разрядностью и гибкой системой
команд. Такой МП называется многокристальным (рис. 4).</p>

<div style="float: right; margin: 20px" align="center"><img src="images/028.png" title="Многокристальный секционный процессор"><br>
Рис. 4. Многокристальный секционный процессор</div>

<p>При создании высокопроизводительных многоразрядных микропроцессоров требуется множество аппаратных средств, не реализуемых в доступных БИС,
поэтому возникает необходимость в дальнейшем функциональном разбиении логической структуры МП вертикальными и горизонтальными плоскостями. В
результате такого разделения на конструктивно законченные части создаются условия реализации каждой функции в виде отдельной БИС. Все они образуют
комплект многокристального секционного микропроцессора (рис. 3) с произвольной разрядностью и гибкой системой команд. Таким образом,
микропроцессорная секция – это БИС, предназначенная для обработки нескольких разрядов данных или выполнения определённых управляющих операций.</p>

<p>2. По <b>организации внешних шин</b> различают микропроцессоры с раздельными или совмещенными шинами адреса и данных.</p>

<p>3. По <b>организации внутренних шин</b> различают микропроцессоры с одной, двумя и тремя внутренними шинами.</p>

<p>В одношинных МП все его элементы имеют одинаковый интерфейс и подключены к единой информационной шине, по которой передаются коды данных, адресов
и управляющих сигналов. В многошинных процессорах его элементы группами подключаются к своей информационной шине. Это позволяет осуществить
одновременную передачу информационных сигналов по нескольким (или всем) шинам. Такая организация систем усложняет их конструкцию, однако,
увеличивает производительность.</p>

<p>4. По <b>организации стека</b> различают микропроцессоры со встроенным, расположенным на кристалле МП и автономным стеком, который реализован в
оперативной памяти.</p>

<p>5. МП также различают по их возможности выполнять за один машинный цикл одну или более команд. Это возможно при построении МП <b>по конвейерному
принципу</b>, что позволяет совместить по времени несколько операций выполнения команды. При этом рационально используются аппаратные ресурсы и
повышается производительность. Однако это ведёт к резкому росту транзисторного бюджета, увеличивает площадь кристалла, а значит и его стоимость. Если
архитектура вычислительного ядра имеет несколько декодеров команд, которые могут нагружать работой множество исполнительных блоков (т.е. имеет
несколько конвейеров), то такие МП называют суперскалярными. Планирование исполнения потока команд в них является динамическим и осуществляется самим
вычислительным ядром.</p>

<p>6. По <b>количеству одновременно выполняемых потоков команд</b> микропроцессоры делят на одно- и многопоточные. ЭВМ с многопоточным МП
рассматривается программным обеспечением как система, имеющая более одного центрального процессора со своими наборами РОН, хотя и не всегда с
соответствующим количеством АЛУ и устройств управления. ЭВМ с многопоточным МП способна выполнять более одного потока команд (более одной программы)
одновременно. Если же каждый набор РОН многопоточного МП имеет ещё и собственный исполнительный блок (ядро), то такой процессор называют
<b>многоядерным</b>.</p>
<br><br>




<a name="2.3"></a><p class="h3">2.3 Организация шин микропроцессорных систем</p>

<p>Все функциональные блоки, как в самом микропроцессоре, так и в микроЭВМ, объединяются с помощью набора проводников, называемого шиной.
Посредством шины данных осуществляется обмен информацией между блоками ЭВМ. Шина адреса используется для передачи адресов, по которым осуществляется
обращение к различным устройствам ЭВМ. Шина управления необходима для передачи управляющих сигналов. Различают внутренние (в самом микропроцессоре)
и внешние шины, а также МП с одной, двумя и тремя внутренними шинами (рис. 5).</p>

<div align="center">
<table>
  <tr> <td><img src="images/029.png"></td> <td><img src="images/030.png"></td> <td><img src="images/031.png"></td> </tr>
  <tr valign=bottom align=center> <td>а</td> <td>б</td> <td>в</td> </tr>
</table>
Рис. 5. Топология:<br>
а – трёхшинная, б – двухшинная, в – одношинная
</div>

<p>Трёхшинная топология не требует буферных регистров, поэтому возможно выполнение арифметических и логических операций за один такт, включая выборку
операндов из РОН и запись результатов в один из регистров. Этот способ помимо высокого быстродействия имеет еще одно важное достоинство – отсутствие
буферных регистров. Главный недостаток такой топологии заключается в значительной занимаемой площади шин на кристалле (до 18%).</p>

<p>Рационального баланса между числом внутренних шин и числом элементов микропроцессора можно достичь при двухшинной организации, которая при меньшей
площади, занимаемой шинами на кристалле, требует введения по меньшей мере одного буферного регистра. Это значит, что арифметические и логические
операции в таком МП будут выполняться не менее чем за два такта:</p>

<p>1) загрузка буферного регистра одним из операндов;</p>
<p>2) выполнение операции в АЛУ над содержимым буферного регистра и одного из РОН; запись результата в РОН.</p>

<p>Наконец, возможна организация МП на основе только одной шины. Наименьшая площадь, занимаемая шиной по сравнению с рассмотренными выше вариантами,
позволяет в максимальной степени усложнить архитектуру МП при фиксированной площади кристалла. Однако необходимость введения не менее двух буферных
регистров увеличивает цикл выполнения операций уже до трёх тактов:</p>

<p>1) загрузка буферного регистра одним из операндов;</p>
<p>2) загрузка второго буферного регистра вторым операндом;</p>

<p>3) выполнение операции в АЛУ над содержимым буферных регистров и запись результата в РОН.</p>

<p>При построении вычислительной системы необходимо учитывать, что выходные линии шин МП позволяют подключать не более одной-двух TTL-нагрузок,
поэтому необходимо использовать внешние буферные усилители (шинные формирователи). Внешние шины обеспечивают связь микропроцессора с ОЗУ, ПЗУ и
портами вода/вывода. При их организации существует два ограничения:</p>

<p>1) на количество внешних выводов БИС;</p>
<p>2) на нагрузочную способность линий.</p>

<p>Ограничение количества внешних выводов корпуса микросхемы привело к появлению микропроцессоров с совмещенной (мультиплексированной) шиной
(рис. 6), по которой в разные моменты времени передаются сигналы как адреса, так и данных.</p>

<p>Характерной особенностью шины данных является её двунаправленность. Под двунаправленностью понимается возможность передачи данных в разные
моменты времени в различных направлениях, например, сначала по шине данных можно передавать данные от процессора к периферии, а затем в обратном
направлении. Двунаправленность шины данных обеспечивается трёхстабильными буферными регистрами, через которые периферийные устройства подключаются к
шине. Выходы трёхстабильных регистров, кроме состояний логического 0 и логической 1, могут принимать третье пассивное, или, так называемое,
высокоимпедансное состояние, благодаря чему они оказываются как бы отключенными от соответствующих линий шины данных.</p>

<div align="center"><img src="images/032.png"><br>
Рис. 6. Микропроцессор:<br>
а – с раздельными шинами, б – с совмещёнными шинами</div>

<p>Шина данных является двунаправленной, а её разрядность определяет количество информации, которой способен обмениваться МП с другими устройствами
за единицу времени. Разрядность шины данных обычно кратна восьми (8, 16, 32, 64, …) бит.</p>

<p>Другое важное понятие – <i>разрядность микропроцессора</i>. Говоря о нём, имеют ввиду разрядность его регистров общего назначения, а не
разрядность внутренней или внешней шины данных. К тому же они могут и не совпадать. Так, 16-разрядный i8088, который был прародителем современных
десктопных процессоров с системой команд x-86, имел более узкую, 8-битную внешнюю шину данных. А 32-разрядный Pentium – наоборот, 64-битную шину
данных для быстрой загрузки внутренней кэш-памяти.</p>

<p>Разрядность шины адреса характеризует максимальный размер адресного пространства памяти, к которой может иметь доступ МП, хотя не обязательно,
что в системе такой объём физически присутствует. Количество адресных линий n определяет 2<sup>n</sup> ячеек памяти, т.е., к примеру, с помощью 16
адресных линий МП может работать с 2<sup>16</sup> = 65536 ячейками памяти. В простых микропроцессорных системах шина адреса однонаправленная, т.к.
только процессор может генерировать сигналы кода адреса, а остальные устройства – только воспринимать их. Шина адреса также используется для выбора
портов ввода-вывода.</p>

<p>Шина управления состоит из набора линий для определения операций и состояний работы различных узлов ЭВМ – сброс, чтение/запись памяти, захват шин,
подтверждение захвата шин, сигналы прерываний, прямой доступ к памяти, и другие. Каждый МП имеет уникальную систему сигналов управления. Все эти
сигналы в электронной системе согласованы с системными тактовыми импульсами синхронизации. Эти сигналы задают начало и последовательность
срабатывания всех элементов ЭВМ. Для формирования системных тактовых импульсов применяется генератор, стабилизированный кварцевым резонатором.</p>

<p>При использовании шинной организации как внутри кристалла, так и при подключении нескольких БИС к одной шине возникает дополнительная трудность,
связанная со способом связи нескольких элементов с одним проводником общей шины. В качестве примера проанализируем способы организации общей шины в
МП, выполненном по схеме на рис. 4, в). С каждым проводником общей шины связаны три входа (РОН, буферный регистр и регистр сдвига) и два выхода (РОН,
АЛУ). Известны три способа решения этой задачи (рис. 6): логическим объединением, объединение с помощью схем с открытым коллектором и объединение с
использованием схем с тремя устойчивыми состояниями.</p>

<div align="center">
<table>
  <tr> <td colspan="3"><img src="images/033.png"></td> </tr>
  <tr valign=bottom align=center> <td>а</td> <td>б</td> <td>в</td> </tr>
</table>
Рис. 7. Подключение нескольких источников к одной шине:<br>
а – логическим объединением, б – «монтажным ИЛИ», в – объединением на базе схем с тремя устойчивыми состояниями</div>

<p>Логическое объединение (рис. 6, а) выполняется с помощью схемы ИЛИ, на входы которой при подаче управляющего сигнала на общей шине появляется
выходной сигнал АЛУ, а при подаче сигнала – выходной сигнал РОН. Этот способ может использоваться при создании внутренней шины (на кристалле).
Объединение с помощью схем с открытым коллектором характеризуется электрическим соединением выходов нескольких логических элементов. Поэтому этот
способ часто называют «монтажным ИЛИ» (рис. 6, б). При простом соединении выходов элементов отпадает необходимость в схеме ИЛИ, используемой при
логическом соединении, а следовательно, нет принципиального ограничения на число объединяемых выходов. Это позволяет применять данный способ при
организации не только внутренних, но и внешних шин, учитывая, однако, что количество объединяемых линий ограничено конечным сопротивлением закрытых
транзисторов, что фактически ограничивает область применимости этого способа организации.</p>

<p>Логическим его развитием, устраняющим указанный недостаток, является использование в качестве нагрузочного резистора нелинейного элемента.
Объединение с использованием схем с тремя состояниями отличается именно таким характером нагрузки. Третье состояние обеспечивается, когда оба
транзистора одного каскада закрыты. Этот способ широко применяются при организации внешних шин, которые реализуются в виде дорожек печатной платы или
плоского кабеля.</p>
<br><br>



<a name="2.4"></a><p class="h3">2.4 Обработка информации в микропроцессоре</p>

<p>Рассмотрим процесс обработки информации в микропроцессоре на примере упрощённой схемы, представленной на рис. 8.</p>

<p>Микропроцессор имеет:</p>

<ul>
  <li>РОН – регистры общего назначения, которые используются для хранения данных и адресов. Кроме РОН в МП имеются специальные регистры: счётчик
   команд, указатель стека и др.;</li>
  <li>БР – буферный регистр, используется для промежуточного хранения операнда, иногда выполняет функции регистра сдвига;</li>
  <li>АЛУ – комбинационная схема, построенная на логических элементах И, ИЛИ, НЕ, выполняющая арифметические и логические преобразования
   информации.</li>
</ul>

<div align="center"><img src="images/034.png" title="Упрощённая схема микропроцессора"><br>
Рис. 8. Упрощённая схема микропроцессора</div>

<p>Выполнение команд разбивается на такты и осуществляется в операционном устройстве под управлением УУ. Рассмотрим пример выполнения операции
сложения R<sub>0</sub> &rarr; R<sub>1</sub> = R<sub>0</sub>:</p>

<p>Такт 1. R<sub>0</sub> &rarr; Шина 2 &rarr; БР ; данные R<sub>0</sub> &rarr; по шине 2 передаются в БР</p>

<p>Такт 2. R<sub>1</sub> &rarr; Шина 2 &rarr; АЛУ ; данные R<sub>1</sub> по шине 2 передаются в АЛУ</p>

<p>Такт 3. Сложение в АЛУ</p>

<p>Такт 4. АЛУ &rarr; Шина 1 &rarr; R<sub>0</sub> ; результат АЛУ по шине 1 передаётся в R<sub>0</sub></p>

<p>Эта схема универсальна, т.к. позволяет выполнять множество различных операций. Для работы операционного устройства необходимо формировать
управляющие сигналы, обеспечивающие выдачу синхроимпульсов для чтения, записи, адресацию РОН и настройку АЛУ на конкретную операцию. При выполнении
арифметических, логических и некоторых других операций в специальном регистре слова-состояния программы формируются признаки (флаги) результата,
необходимые для операций условного перехода. Реализация более сложных команд требует использования специальных блоков (умножения, деления, и др.).
Для ускорения выполнения определённых операций вводятся дополнительно специальные операционные узлы (например циклические сдвигатели).</p>

<p>Кроме указанных блоков микропроцессор имеет ряд служебных регистров.</p>

<p><i>Регистр флагов</i> (регистр статуса или регистр слова-состояния процессора) предназначен для фиксации и хранения признака, характеризующего
результат последней выполненной арифметической или логической операции. К примеру, флаг равенства результата нулю, знак результата, возникновение
переноса из старшего разряда, и т. д. Содержимое регистра флагов используется устройством управления для реализации условных переходов.</p>

<p><i>Счётчик команд</i>. Согласно принципу выполнения программ, её соседние команды располагаются в ячейках памяти со следующими по порядку
адресами и выполняются преимущественно в той же очерёдности, в какой они размещены в памяти ЭВМ. Таким образом, адрес очередной команды может быть
получен путём увеличения адреса ячейки, из которой была считана текущая команда, на длину выполняемой команды, представленную числом занимаемых ею
ячеек. Реализацию такого режима и призван обеспечивать счётчик команд – двоичный регистр, в котором хранится и модифицируется адрес очередной
команды программы. Перед началом вычислений в СК заносится адрес ячейки основной памяти, где хранится команда, которая должна быть выполнена первой.
В процессе выполнения каждой команды путём увеличения содержимого СК на длину выполняемой команды в счётчике формируется адрес следующей подлежащей
выполнению команды. В данном случае любая команда занимает одну ячейку, поэтому содержимое СК увеличивается на единицу. По завершении текущей
команды адрес следующей команды программы всегда берётся из счётчика команд. Для изменения естественного порядка вычислений (перехода в иную точку
программы) достаточно занести в СК адрес точки перехода.</p>

<p><i>Регистр команд</i>. Счётчик команд определяет лишь местоположение ко-манды в памяти, но не содержит информации о том, что это за команда.
Чтобы приступить к выполнению команды, её необходимо извлечь из памяти и разместить в регистре команд (РК). Этот этап носит название выборки команды.
Только с момента загрузки команды в РК она становится «видимой» для процессора. В РК команда хранится в течение всего времени её выполнения.</p>
<br><br>



<a name="2.5"></a><p class="h3">2.5 Управление обработкой информации</p>

<p>Управление операциями в ЭВМ осуществляет устройство управления с помощью управляющих сигналов, генерируемых по командам программы. Коды операции
команд программы, воспринимаемые управляющей частью микропроцессора, расшифрованные и преобразованные в ней, дают информацию о том, какие операции
требуется выполнить, где в памяти расположены данные, куда необходимо направить результат и где расположена следующая за выполняемой команда.</p>

<p>Большинство современных процессоров для персональных компьютеров основаны на той или иной версии циклического процесса последовательной обработки
данных, предложенного Джоном фон Нейманом в 1946 году. Отличительной особенностью архитектуры фон Неймана является то, что команды и данные хранятся
в одной и той же памяти.</p>

<p>В соответствии с циклом фон Неймана (рисунок 9), устройство управления в рамках тактовых интервалов (такт – минимальный рабочий интервал, в
течение которого совершается одно элементарное действие; цикл – интервал времени, в течение которого выполняется одна машинная операция)
осуществляет: <i>выборку команды</i>. При этом процессор выставляет число, хранящееся в счётчике команд, на шину адреса и выдаёт памяти команду
чтения. Выставленное число является для памяти адресом; память, получив адрес и команду чтения, извлекает содержимое, хранящееся по этому адресу, и
выставляет его на шину данных, сопровождая сигналом готовности. Процессор получает число с шины данных, помещает его в регистр команд.</p>

<div align="center" style="float: right; margin-left: 10px"><img src="images/035.gif" title="Процесс выполнения команды в МП"><br>
Рис. 9. Процесс выполнения команды в МП</div>

<p>На этапе <i>дешифрации</i> процессор интерпретирует содержимое регистра команд как машинную инструкцию. При этом производится анализ формата,
служебных признаков и вычисление адреса операнда (операндов); установливается временная последовательность функциональных управляющих сигналов;
формирование управляющих импульсов и передача их на шины функциональных частей ЭВМ.</p>

<p>При этом на <i>третьем этапе</i> фаза выборки может повторяться, если команда длинная и не помещается в одну ячейку памяти. Если команда не
является командой перехода, процессор увеличивает на единицу (в предположении, что длина каждой команды равна единице) содержимое счётчика команд; в
результате там образуется адрес следующей команды.</p>

<p>На <i>четвёртом этапе</i> производится выполнение команды, анализ результата, и сохранение.</p>

<p>Данный цикл выполняется неизменно, и именно он называется процессом (откуда и произошло название устройства). Во время процесса процессор
считывает последовательность команд, содержащихся в памяти, и исполняет их. Такая последовательность команд называется программой и представляет
алгоритм работы процессора. Очерёдность считывания команд изменяется в случае, если процессор считывает команду перехода, – тогда адрес следующей
команды может оказаться другим. Другим примером изменения процесса может служить случай получения команды остановка или переключение в режим
обработки прерывания.</p>

<p>Команды центрального процессора являются самым нижним уровнем управления компьютером, поэтому выполнение каждой команды неизбежно и безусловно.
Не производится никакой проверки на допустимость выполняемых действий, в частности, не проверяется возможная потеря ценных данных. Чтобы компьютер
выполнял только допустимые действия, команды должны быть соответствующим образом организованы в виде необходимой программы.</p>

<p>Скорость перехода от одного этапа цикла к другому определяется тактовым генератором, который вырабатывает импульсы, служащие ритмом для
центрального процессора. Частота тактовых импульсов называется тактовой частотой.</p>

<p>Одной из самых сложных частей компьютерного проектирования является создание управляющей логики, которая диктует каждой части процессора что
делать, чтобы выполнить определенную команду. В микропроцессорах используют два метода выработки совокупности функциональных управляющих сигналов:
<i>аппаратный</i> и <i>микропрограммный</i>.</p>

<p>Выполнение операций в машине сводится к элементарным преобразованиям информации (передача информации между узлами в блоках, сдвиг информации в
узлах, логические поразрядные операции, проверка условий и т.д.) в логических элементах, узлах и блоках под воздействием функциональных управляющих
сигналов устройства управления. Элементарные преобразования, не разложимые на более простые, выполняются в течение одного такта сигналов
синхронизации и называются микрооперациями.</p>

<p>В аппаратных (схемных) устройствах управления (рис. 10) каждой операции соответствует свой набор логических схем, вырабатывающих определённые
функциональные сигналы для выполнения микроопераций в определенные моменты времени. Для каждого кода операции (КОП) Yi выдаются в течение
нескольких тактов. УУ оптимизируется для конкретной системы команд, которую в дальнейшем изменить нельзя. При этом способе построения устройства
управления реализация микроопераций достигается за счет однажды соединённых между собой логических схем, поэтому ЭВМ с аппаратным устройством
управления называют ЭВМ с жёсткой логикой управления. Это понятие относится к фиксации системы команд в структуре связей ЭВМ и означает практическую
невозможность каких-либо изменений в системе команд ЭВМ после её изготовления.</p>

<div align="center" style="float: left; margin-right: 10px"><img src="images/036.gif" title="Аппаратное устройство управления"><br>
Рис. 10. Аппаратное устройство управления</div>

<p>В 1951 году британский учёный в области компьютерных наук Морис Уилкс предложил идею микрокода: вместо построения управляющей логики из сложных
схем логических элементов, управляющая логика может быть заменена специальным кодом – микрокодом. Чтобы выполнить команду, компьютер выполняет
несколько простых микрокоманд, которые задаются микрокодом. С помощью микрокода построение управляющей логики процессора становится задачей
программирования, а не задачей логического проектирования.</p>

<p>Такой способ называется микропрограммной реализацией устройства управления (рисунок 11). При этом в состав последнего вводится ЗУ, каждый разряд
выходного кода которого определяет появление функционального сигнала управления. Поэтому каждой микрооперации ставится в соответствие свой
информационный код – микрокоманда. Набор микрокоманд и последовательность их реализации обеспечивают выполнение любой сложной операции. Набор
микроопераций называют микропрограммами. Способ управления операциями путём последовательного считывания и интерпретации микрокоманд из ЗУ (наиболее
часто в виде микропрограммного ЗУ используют быстродействующие программируемые логические матрицы), а также использования кодов микрокоманд для
генерации функциональных управляющих сигналов называют микропрограммным. При этом Yi для всех команд и всех тактов записываются в ПЗУ в виде
микрокоманд. Микрокоманды имеют разрядность 50…100, поэтому для сокращения длины их кодируют, а затем декодируют. Адрес первой микрокоманды
определяет КОП, а каждая микрокоманда соответствует одному такту.</p>

<div align="center" style="float: right; margin-left: 10px"><img src="images/037.gif" title="Микропрограммное устройство управления" width="403"><br>
Рис. 11. Микропрограммное устройство управления:<br>
М/к – микрокоманда;<br>
ДШ – дешифратор;<br>
СУ – схема управления<br></div>

<p>Микрокод был обычным явлением в мэйнфреймах 60-х годов, но ранние микропроцессоры, такие как i8080, 6502 и Z-80, не использовали микрокод,
поскольку не имели места для его хранения. Однако в более поздних процессорах, таких как i8086 и Motorolla 68000, применяли микрокод, используя
преимущество увеличения плотности микросхем. Это позволило в i8086 реализовать сложные команды (такие как умножение и копирование строк), без
усложнения схемы. Недостаток такого подхода заключался в необходимости значительной части площади кристалла: на рисунке 12 схема микрокода показана
в правом нижнем углу фотографии.</p>

<p>Под микроскопом видно содержимое микрокода; биты могут быть считаны в зависимости от наличия или отсутствия транзисторов в каждой позиции. ПЗУ
состоит из 512 микрокоманд, каждая шириной в 21 бит. Каждая из них определяет перемещение данных между источником и получателем. Она также
определяет микрокоманду, которая может быть командой перехода, операцией АЛУ, операцией с памятью, вызовом подпрограммы микрокода или его учётом.
Микрокод довольно эффективен; простые команды, такие как инкремент или декремент, состоят из двух микрокоманд, в то время как более сложное
копирование строки реализовано при помощи восьми микрокоманд.</p>

<div align="center">
<table>
  <tr> <td><img src="images/8086_PhotoOfChip.jpg" width="300"> <img src="images/8086_PhotoOfChipFunctionalBlocks.jpg" width="300"></td> </tr>
  <tr valign=bottom align=center> <td><img src="images/8086_MicroCode.jpg" width="250"></td></tr>
</table>
Рис. 12. Фото кристалла i8086</div>

<p>К микропрограммам предъявляют требования функциональной полноты и минимальности. Первое требование необходимо для обеспечения возможности
разработки микропрограмм любых машинных операций, а второе связано с желанием уменьшить объём используемого оборудования. Учёт фактора быстродействия
ведёт к расширению микропрограмм, поскольку усложнение последних позволяет сократить время выполнения команд программы.</p>
<br><br>




<a name="2.6"></a><p class="h3">2.6 Архитектура 8-разрядного микропроцессора</p>

<p>Типичным представителем 8-битных однокристальных микропроцессоров является разработанный фирмой Intel в 1974 г. i8080 или его советский аналог
К580ИК80. Кристалл процессора производился по технологическим нормам 6 мкм, вмещал 6000 транзисторов и имеел тактовую частоту 2 МГц, а более
поздний его вариант i8080A (советский аналог К580ВМ80А) – 2,5 МГц. Процессор снабжён 8-разрядной шиной данных, 16-разрядной шиной адреса, с помощью
которой адресует 2<Sup>16</Sup> = 64 Кбайт памяти, 256 устройств ввода и 256 устройств вывода. МП работает от трёх источников питания – +5, +12 и
–5В и рассеивает мощность 1,25 Вт. Длительность такта при частоте 2 МГц составляет 0,5 мкс, при этом быстродействие – 500&nbsp;000 коротких операций
(регистр-регистр) в секунду.</p>

<p>Программно-аппаратная модель i8080 представлена на рис. 13.</p>

<div align="center"><img src="images/038.jpg" width="400" style="margin:0 20px 40px;"> <img src="images/039.gif"><br><br>
Рис. 13. Фото и программно-аппаратная модель i8080</div><br><br>

<div align="center"><img src="images/040.png"><br><br>
Рис. 14. Структурная схема i8080</div><br>

<p>Арифметическо-логическое устройство (АЛУ) обеспечивает выполнение арифметических, логических операций и операций сдвига над двоичными данными,
представленными в дополнительном коде, или над двоично-десятичными данными. Устройство содержит схему десятичной коррекции (СДК), позволяющую
производить операции десятичной арифметики. По результатам операций в АЛУ формируется ряд признаков, которые записываются в регистр флагов F.
Флаг переноса С устанавливается в единицу, если в результате выполнения команды появляется перенос из старшего разряда. Дополнительный признак
переноса AС устанавливается в единицу при возникновении переноса из третьего разряда. Используется в командах десятичной арифметики. Флаг чётности
Р устанавливается в единицу, если число единиц в разрядах результата чётное. Флаг нуля Z устанавливается в единицу, если результат равен нулю.
Флаг знака S указывает знак числа и равен единице, если число отрицательное, или нулю, если число положительное.</p>

<p>Блок регистров производит приём, хранение и выдачу различной информации, участвующей в процессе выполнения программы, и содержит счётчик команд
(Program Counter, PC), указатель стека (Stack Pointer, SP), регистры общего назначения (РОН), регистры временного хранения и регистр адреса.
16-разрядный счётчик команд хранит текущий адрес команды. Содержимое счётчика команд автоматически увеличивается после выборки каждого байта команды.
16-разрядный указатель стека содержит начальный адрес памяти, используемый для хранения и восстановления содержимого программно-доступных регистров
МП. Содержимое указателя стека уменьшается, когда данные загружаются в стек, и увеличивается, когда данные выбираются из стека. 8-разрядные регистры
общего назначения В, С, D, Е, Н, L могут применяться как накопители и указатели (16-разрядный адрес операнда определяется содержимым пары регистров).
Основной однобайтный регистр процессора – это аккумулятор A. Над его содержимым выполняется наибольшее количество арифметических и логических команд,
а также команды ввода/вывода. Регистры временного хранения W, Z используются для приема и временного запоминания второго и третьего байт команд
переходов, передаваемых с внутренней магистрали ЦПУ в счётчик команд. Эти регистры являются программно-недоступными. 16-разрядный регистр адреса
принимает и хранит в течение одного машинного цикла адрес команды или операнда и выдает его через буфер адреса на однонаправленную выходную
шину А0-А15. Буфер адреса выполнен в виде выходных формирователей, имеющих на выходе состояние «Отключено».</p>

<p>Устройство управления формирует комплекс управляющих сигналов, организующих выполнение поступившей в МП команды, и состоит из регистра команд,
программируемой логической матрицы (ПЛМ) и схемы управления узлами. 8-разрядный регистр команд осуществляет прием и хранение команды, поступающей по
шине данных. Программируемая логическая матрица дешифрирует код операции команды и формирует микрооперации в соответствии с микропрограммой
выполнения команды. Схема управления узлами вырабатывает для различных узлов микропроцессора необходимые управляющие сигналы. 8-разрядный буфер
данных обеспечивает ввод команд и данных в МП, вывод данных через формирователи, имеющие высокоомное состояние.</p>

<p>Сигнал «Сброс» обнуляет счётчик команд PC (но не регистры), что эквивалентно выполнению программы с адреса 0000H.</p>

<p>Схема синхронизации и управления состояниями МП формирует машинные такты и циклы, которые координируют выполнение всех команд, и вырабатывает
сигнал SYNC «Синхронизация», определяющий начало каждого машинного цикла. Для выполнения команды требуется 1–5 машинных циклов, каждый из которых
может состоять из 3–5 тактов (Т1-Т5). Длительность каждого из них соответствует периоду следования противофазных тактовых импульсов Ф1, Ф2.</p>

<p>Первый цикл выполнения любой команды, – это цикл выборки (такт Т1), в котором содержимое счётчика команд выдаётся на адресную шину, а на шину
данных – слово-состояние машинного цикла (ССМЦ), сопровождаемое сигналом синхронизации, по которому это слово записывается в буферный регистр
внешних схем управления. ССМЦ позволяет различить 10 типов машинного цикла (чтение первого байта команды, ввод/вывод, чтение/запись в память,
чтение/запись в порты ввода/вывода). В такте Т2 содержимое счётчика команд увеличивается на единицу и осуществляется анализ управляющих сигналов
«Готовность» и «Захват шин». В цикле чтения/записи на такте Т3 данные принимаются из памяти по шине данных и записываются в регистр команд (если
выполняется цикл выборки команды) или в один из регистров МП. В тактах Т4 и Т5, если они необходимы, выполняются действия над операндами. Если
команда включает несколько циклов, то по завершении текущего машинного цикла процессор переходит к такту Т1 следующего цикла.</p>
<br><br>




<a name="2.7"></a><p class="h3">2.7 Типы архитектур МП</p>

<p>Команды, составляющие программу, хранятся в памяти ЭВМ. И чем быстрее процессор сможет получить необходимые данные, и вернуть результат, тем,
очевидно, его работа будет эффективнее. В связи с этим, различают несколько архитектур МП, основанные на различном принципе взаимодействия с
операционным блоком:</p>

<ul>
  <li>регистровая;</li>
  <li>стековая;</li>
  <li>архитектура, ориентированная на память.</li>
</ul>

<p><i>Регистровая архитектура</i> определяет наличие большого регистрового файла внутри БИС МП (поле памяти с произвольной записью и выборкой
информации). Её достоинства в высокой скорости работы и использовании сокращённой адресации из-за небольшой длины команд. Но при частой смене
программ (мультипрограммирование, задачи управления) эффективность этой архитектуры падает, т.к. при переключении необходимо сохранять и перегружать
содержимое регистров. Кроме того, большое количество регистров трудно расположить на кристалле из-за меньшей плотности расположения логических схем,
чем схем памяти. Часто регистровое поле называют регистровым сегментом RSEG.</p>

<p><i>Стековая архитектура</i> использует поле памяти с упорядоченной последовательностью записи и выборки информации. Она эффективна при работе с
подпрограммами (задачи управления), однако стек на кристалле мал и быстро переполняется. Эта архитектура практически не применяется как
самостоятельная, а служит дополнением к другим видам архитектур.</p>

<p><i>Архитектура память-память</i> обеспечивает расположение регистров и стека в ОЗУ. Операнды, после выборки из ОЗУ, обработки в МП заносятся
обратно в память, а не сохраняются на регистрах. Оценку этого способа необходимо производить с учётом быстродействия МП и ОЗУ. Например, в
микроконтроллерах, где ОЗУ расположено на кристалле и имеет быстродействие сравнимое с быстродействием остальных схем, эта архитектура эффективна.
Если ОЗУ расположено вне кристалла и имеет небольшое быстродействие, то это неэффективно. Достоинства этой архитектуры в фактически неограниченной
свободе размещения данных (большое количество регистров в ОЗУ); быстрое контекстное переключение, т.к. для переключения регистрового (контекстного)
файла необходимо только изменить регистр-указатель начального адреса; упрощена связь с другими МП в многопроцессорных системах и контроллерах внешних
устройств. Однако наличие двухадресных команд увеличивает длину программ.</p>

<p>Архитектура память-память часто используется в микро ЭВМ, контролерах для работы в реальном режиме времени, при большом количестве прерываний,
вызовов подпрограмм, мультипрограммировании, и т.д..</p>

<p>Развитием регистровой архитектуры, преодолевшей её недостатки, является <i>ортогональная регистровая архитектура</i>. Развитие аппаратных средств,
увеличение плотности компоновки позволило на кристалле МП разместить дополнительные (избыточные) блоки регистров, которые могут использоваться для
сохранения ортогональных (других) состояний МП. При переключении с программы на программу, содержимое соответствующего блока регистров не
переписывается в оперативную память и перезагружается в него содержимое для новой программы. Вместо этого каждой программе выделяется собственный
блок регистров. Чем больше таких ортогональных направлений, тем эффективнее работа МП с обслуживанием прерываний и подпрограмм. Выбор банка регистров
осуществляется либо специальными командам, либо автоматически при входе в подпрограммы.</p>

<p><i>Фон Неймановская (принстонская)</i> и <i>Гарвардская архитектуры</i> построения ЭВМ определяют взаимное расположение команд и данных.</p>

<p>Фон Неймановская (принстонская) архитектура, которая предложена Джоном фон Нейманом в 1945 г. предполагает, что программа и данные находятся в
общей памяти, доступ к которой производится по одной шине данных и управления. Основным достижением группы инженеров, работавших с фон Нейманом,
было осознание того факта, что программа может храниться в памяти вместе с данными. Основным преимуществом такого подхода является его гибкость, так
как для изменения программы достаточно просто загрузить новый код в соответствующую область памяти. По существу, фон-неймановская архитектура,
показанная на рисунке 15 а), состоит из центрального процессора (ЦП), памяти и общей шины, по которой в обоих направлениях пересылаются данные. ЦП
также должен взаимодействовать и с окружающим миром. При этом данные к/от соответствующих интерфейсных портов передаются по одной общей шине
данных.</p>

<div align="center">
<table>
  <tr> <td><img src="images/Von-Neumann_Architecture.png"></td> <td colspan="2"><img src="images/Garvard_Architect.png"> </tr>
  <tr valign=bottom align=center> <td>а</td> <td>б</td></tr>
</table>
Рис. 15. Архитектуры построения памяти в микропроцессорных системах:<br>
а – фоннеймановская; б – гарвардская</div>

<p>Огромным преимуществом фон Неймановской архитектуры является её простота, поэтому данная концепция легла в основу большинства компьютеров общего
назначения. Однако использование общей шины означает, что в любой момент времени может выполняться только одна операция передачи информации.
Соответственно, пересылка данных между ЦП и памятью данных не может осуществляться одновременно с выборкой команды.</p>

<p>Гарвардская архитектура (реализована в 1944г. в ЭВМ Гарвардского университета) соответствует структуре с разделёнными устройствами памяти команд
и данных и отдельными шинами команд и данных. В первое послевоенное десятилетие в Гарвардском университете было создано несколько компьютеров
семейства «Марк», в которых память программ была полностью отделена от памяти данных (программа считывалась с бумажной перфоленты). Такая концепция
была более эффективной, чем фон Неймановская, поскольку код программы мог считываться из памяти программ одновременно с обменом между ЦП и памятью
данных или с операциями ввода/вывода. Однако такие машины были намного сложнее и дороже в изготовлении. А с учётом уровня технического развития
40–50-х годов, высоких экономических затрат, они не получили широкого распространения. С развитием больших интегральных схем и технологии гарвардская
архитектура снова оказалась в центре внимания.</p>

<p>На рисунке 15 б) показаны две физически разделённые шины, используемые для передачи информации между ЦП и неперекрывающимися областями памяти.
Каждая память имеет собственную шину адреса, поэтому адрес ячейки памяти программ никоим образом не связан с адресом ячейки памяти данных. В таком
случае говорят, что обе области памяти находятся в различных адресных пространствах. Фон Неймановская архитектура более экономно расходует аппаратные
ресурсы, а гарвардская позволяет реализовать большее быстродействие, поэтому почти все современные микроконтроллеры, выполнены по Гарвардской
архитектуре.</p><br><br>




<a name="2.8"></a><p class="h3">2.8 CISC, RISC и VLIW архитектуры</p>

<p><b>CISC.</b> Поначалу развитие микропроцессоров шло в направлении создания компьютеров, способных выполнять как можно больше различных команд.
Это облегчало ручное написание ассемблерных программ, а использование сложных команд значительно сокращало размеры программы и повышало скорость её
выполнения. В последних версиях ЭВМ выразительность ассемблерного кода зачастую не уступала выразительности программы, написанной на языке высокого
уровня. Одной командой можно было сказать практически всё, что угодно. К примеру, такие ЭВМ, как DEC VAX, аппаратно поддерживали команды “добавить
элемент в очередь”, “удалить элемент из очереди” и даже “провести интерполяцию полиномом”! Отсюда и общее название соответствующих архитектур:
CISC – Complex Instruction Set Computers (“компьютеры с набором команд на все случаи жизни”).</p>

<p>Другая особенность – <i>многие команды допускали все возможные методы адресации</i> – к примеру, и операнды, и результат в арифметических
операциях доступны не только в регистрах, но и через непосредственную адресацию, и прямо в памяти. Подобные команды оказалось сложно не только
выполнять, но и просто декодировать. Чтобы машинный код из-за сложных команд не разрастался до огромного размера, команды имели неоднородную
структуру (разное расположение и размеры кода операции и её операндов) и сильно отличающуюся длину (в x86, например, длина команд варьируется от 1
до 15 байт).</p>

<p>Другой проблемой стало то, что при сохранении приемлемой сложности процессора многие команды оказалось невозможно выполнить “аппаратно”, и
поздние CISC-процессоры имеют специальные блоки, которые “на лету” заменяют сложные команды на последовательность простых. В результате
CISC-процессоры оказались весьма трудоёмкими в проектировании и изготовлении. И, наконец, исследования ПО того времени, проведённые фирмой IBM,
наглядно показали, что даже программисты, пишущие на ассемблере, эти возможности CISC-архитектуры почти никогда не использовали, а компиляторы
языков высокого уровня – и не пытались использовать.</p>

<p>К началу восьмидесятых годов классические CISC полностью исчерпали себя. Расширять набор команд в рамках этого подхода дальше не имело смысла,
наоборот – технологи столкнулись с тем, что из-за высокой сложности CISC-процессоров оказалось трудно наращивать их тактовую частоту, а из-за
“медленности” ОЗУ процессорные расшифровки сложных команд работают медленнее обычных подпрограмм. Поэтому стало очевидным, что CISC-процессоры нужно
упрощать.</p>

<p><b>RISC.</b> <b>R</b>educed <b>I</b>nstruction <b>S</b>et <b>C</b>omputer (компьютер с сокращённым набором команд) – архитектура процессора, в
которой быстродействие увеличивается за счёт упрощения команд, чтобы их дешифрация была простой, а время выполнения – короче. Это также облегчает
повышение тактовой частоты и делает более эффективной суперскалярность (распараллеливание команд между несколькими исполнительными блоками).</p>

<p>Для начала разработчики свели к минимуму набор команд и к абсолютному минимуму – количество режимов адресации памяти; упаковав всё, что осталось,
в простой и удобный для дешифрации регулярный машинный код. В частности, в классическом варианте RISC из команд, обращающихся к оперативной памяти,
оставлены только две (Load – загрузить данные в регистр и Store – сохранить данные из регистра; так называемая Load/Store-архитектура), и нет ни
одной команды вроде вычисления синуса, косинуса или квадратного корня. Первые RISC-процессоры даже не имели команд умножения и деления.</p>

<p>Вторая важная особенность RISC-процессоров, – большое количество РОН (более шестнадцати), причём почти все эти регистры полностью равноправны,
что позволяет компилятору свободно распоряжаться ими, сохраняя большую часть промежуточных данных именно там, а не в стеке или оперативной памяти.
В классическом x86 IA-32 всего восемь РОН, причём каждому из них приписано то или иное “специальное назначение” (в ESP хранится указатель на стек)
затрудняющее или делающее невозможным его использование.</p>

<p>Таким образом, RISC-процессоры в 2..4 раза быстрее имеющих ту же тактовую частоту CISC-процессоров с обычной системой команд, несмотря на больший
объём программ (на 30%). Дейв Паттерсон и Карло Секуин сформулировали 4 основных принципа RISC архитектуры:</p>

<ol>
  <li>Любая команда выполняется за один такт, независимо от её типа.</li>
  <li>Система команд должна содержать минимальное количество наиболее часто используемых простейших команд одинаковой длины.</li>
  <li>Команды обработки данных реализуются только в формате "регистр-регистр" (операнды выбираются из РОН, и результат операции записывается также
    в РОН; а обмен между РОН и памятью выполняется только с помощью команд загрузки-записи).</li>
  <li>Состав системы команд должен быть "удобен" для компиляции операторов языков высокого уровня.</li>
</ol>

<p>Большинство существующих процессоров – RISC-подобные (ARM, AVR, MIPS, PowerPC, ...). Даже МП архитектуры x86 ранее являлись CISC-процессорами, но
начиная с i486, являются CISC-МП с RISC-ядром. Они перед исполнением преобразуют CISC-команды x86 в более простой набор внутренних RISC-команд.
Однако уменьшившаяся сложность RISC-CPU, увеличение тактовой частоты и ускорение исполнения команд привела к увеличению длины программ и сильно
уменьшила их вычислительную плотность (количество вычислений на единицу длины машинного кода). Поэтому при появлении первых RISC-процессоров был
сделан следующий шаг – введён конвейер.</p>

<p><b>VLIW</b> – Very Large Instruction Word, архитектура появилась в 1990-х годах. В суперскалярных процессорах также есть несколько вычислительных
модулей, но задача распределения работы между ними решается аппаратно. Это сильно усложняет устройство процессора. В процессорах VLIW задача
распределения решается во время компиляции и в командах явно указано, какое вычислительное устройство какую команду должно выполнять.

<p>VLIW можно считать логическим продолжением идеологии RISC, расширяющей её на архитектуры с несколькими вычислительными модулями. Так же, как в
RISC, в инструкции явно указывается, что именно должен делать каждый модуль процессора. Из-за этого длина команд может достигать 128 или даже 256
бит, отдельные поля которых содержат коды, обеспечивающие выполнение различных операций. Таким образом, одна команда вызывает выполнение сразу
нескольких операций параллельно в различных операционных устройствах, входящих в структуру микропроцессора. При компиляции программ, написанных на
языке высокого уровня, производится формирование «длинных» VLIW-команд, каждая из которых обеспечивает реализацию процессором целой процедуры или
группы операций.</p>

<p>В то же время код для VLIW обладает невысокой плотностью. Из-за большого количества пустых команд для простаивающих устройств программы для VLIW-
процессоров могут быть гораздо длиннее, чем аналогичные программы для традиционных архитектур.</p>

<p>Примерами микропроцессоров с архитектурой VLIW являются Intel Itanium, РА8500 компании Hewlett-Packard, Qualcomm Snapdragon, МП серии «Эльбрус»
(«Эльбрус 2000», «Эльбрус S»), а также графические видеопроцессоры AMD/ATI Radeon начиная с R600 и до Northern Islands. МП Snapdragon фирмы
Qualcomm, предназначенные для телефонов и планшетов, содержат сопроцессоры с VLIW-архитектурой Hexagon (QDSP6). На нём могут выполняться алгоритмы
обработки звука и мультимедиа, а также часть цифровой обработки беспроводных сигналов. В нём ежетактно могут запускаться на исполнение наборы из 4
команд. Также некоторые типы DSP-цифровых процессоров сигналов построены на базе архитектуры VLIW.</p><br><br>




<a name="2.9"></a><p class="h3">2.9 Конвейерное выполнение команд</p>

<p>Идея конвейера состоит в том, что производительность цепочки последовательных действий определяется длительностью самой сложной операции. Если
разбить выполнение команды на несколько этапов, то тактовая частота будет обратно пропорциональна времени выполнения самого медленного этапа. Если
это время удастся сделать достаточно малым (а чем больше этапов на конвейере, тем они короче), то можно повысить тактовую частоту, а значит, и
производительность МП.</p>

<p>Выполнение любой команды можно разбить как минимум на пять непересекающихся этапов:</p>

<div align="center" style="float: right; margin-left: 20px"><img src="images/042.gif" title="Аппаратное устройство управления"><br>
Рис. 16. Диаграмма выполнения команд</div>

<ol>
  <li>Выборка команды (FETCH) из памяти.</li>
  <li>Декодирование (DECODE). Процессор определяет последовательность действий, необходимых для выполнения команды и переправляет запрос на нужное
   исполнительное устройство.</li>
  <li>Подготовка исходных данных для выполнения команды.</li>
  <li>Выполнение команды (EXECUTE).</li>
  <li>Сохранение полученных результатов.</li>
</ol>

<p>Конвейеризация потенциально применима к любой процессорной архитектуре, независимо от набора команд и положенных в её основу принципов. Даже
самый первый x86-процессор, Intel 8086, уже содержал своеобразный примитивный “двухстадийный конвейер” – выборка новых команд (FETCH) и их
исполнение осуществлялись в нём независимо друг от друга. Однако реализовать что-то более сложное для CISC-процессоров оказалось трудно. Подобных
проблем у RISC-архитектуры гораздо меньше, поэтому конвейеризированные RISC-процессоры появились ранее аналогичных x86.</p>

<p>Существуют три проблемы реализации конвейера.</p>

<p>1. <i>Необходимость наличия блокировок конвейера.</i> Время исполнения команд может сильно варьироваться. Умножение и деление требуют нескольких
тактов, а сложение или побитовые операции – одного такта. Для операций Load и Store, которые могут обращаться к разным уровням кэш-памяти или к
оперативной памяти, это время вообще не определено (и может достигать сотен тактов). Поэтому необходим механизм, притормаживающий выборку и
декодирование новых команд, пока не будут завершены старые. Для решения этой проблемы в процессорах перед исполнительными устройствами появляются
специальные блоки-диспетчеры, которые накапливают подготовленные к исполнению команды, отслеживают выполнение ранее запущенных команд и по мере
освобождения исполнительных устройств отправляют на них новые команды. Даже если исполнение займёт много тактов – внутренняя очередь диспетчера
позволит в большинстве случаев не останавливать подготавливающий всё новые и новые команды конвейер. Новые команды также удаётся декодировать не
каждый такт, поэтому возможна обратная ситуация, когда новых команд за такт не появилось, и диспетчер отправляет команды на выполнение “из старых
запасов”. Так в процессоре возникает разделение на две независимо работающие подсистемы: Front-end – блоки, занимающиеся декодированием команд и их
подготовкой к исполнению, и Back-end – блоки, исполняющие команды.</p>

<p>2. <i>Необходимость наличия системы сброса процессора.</i> Поскольку операции FETCH и EXECUTE всегда выделены в отдельные стадии конвейера, то в
тех случаях, когда в программном коде происходит условный переход, зачастую оказывается, что по какой из веток пойти – пока неизвестно: команда,
вычисляющая код условия, ещё не выполнена. В результате процессор вынужден либо приостанавливать выборку новых команд, пока не будет вычислен код
условия (а это может занять очень много времени и в типичном цикле затормозит процессор), либо, руководствуясь соображениями блока предсказания
переходов, “угадывать”, какой из переходов скорее всего окажется правильным.</p>

<p>3. Наконец, конвейер обычно требует <i> наличия специального планировщика решающего конфликты по данным.</i> Если в программе идёт зависимая
цепочка команд (когда команда-2, следующая за командой-1, использует для своих вычислений данные, только что вычисленные командой-1), а время
исполнения одной команды превосходит один такт, то приходится придержать выполнение очередной команды, до выполнение её предшественницы. Рассмотрим,
к примеру, вычисление выражения A•B+C с сохранением результата в переменной X (X=A•B+C). МП, должен вначале дождаться, пока первая команда сохранит
результат умножения A•B, и только потом прибавлять к полученному результату число С. Цепочки зависимых команд в программах – скорее правило, нежели
исключение, а исполнение команды с записью результата в регистры за один такт – наоборот, скорее исключение, нежели правило, поэтому в той или иной
степени с проблемой зависимости по данным любая конвейерная архитектура обязательно сталкивается. Таким образом, в конвейере появляются сложные
декодеры, заранее выявляющие эти зависимости, и планировщики, которые запускают команды на исполнение, выдерживая паузу между запуском главной
команды и зависимой от неё.</p>

<p>Идея конвейера в процессоре очень красива на словах и в теории, однако реализовать её даже в простом варианте чрезвычайно трудно. Но выгода от
конвейеризации столь велика и несомненна, что приходится с этими трудностями мириться, ведь ничего лучшего до сих пор не придумано.</p>

<p>В 1991-92 годах Intel, выпустила i486 с миллионом транзисторов – CISC-МП с пятистадийным конвейером. Тактовую частоту по сравнению с i386
введение конвейера позволило увеличить втрое, а производительность на единицу частоты – вдвое. В i386 многие команды выполнялись за несколько
тактов; а в i486 среднее “время” исполнения команды в тактах удалось снизить почти вдвое. Правда, расплатой за это стала чудовищная сложность ядра
i486, но быстро растущие технологические возможности кремниевой технологии уже через пару лет позволили освоить производство i486 всем желающим. Но
к тому моменту RISC-архитектуры сделали ещё один шаг вперед – к <b>суперскалярным процессорам</b>.</p>

<p>Суперскалярность – архитектура вычислительного ядра, использующая несколько декодеров команд, которые могут нагружать работой множество
исполнительных блоков. Планирование исполнения потока команд является динамическим и осуществляется самим вычислительным ядром.</p>
<br><br>




<a name="2.10"></a><p class="h3">2.10 Блок предсказания переходов</p>

<p>Блок предсказания условных переходов – устройство МП определяющее направление ветвлений в исполняемой программе. Он позволяет осуществлять
предварительную выборку команд и данных из памяти, а также выполнять команды, находящиеся после условного перехода, до того, как он будет выполнен.
Существует два основных метода предсказания переходов: статический и динамический.</p>

<p>Статические методы предсказания ветвлений являются наиболее простыми. Их суть состоит в том, что различные типы переходов либо выполняются
всегда, либо не выполняются никогда. Например, предполагается, что условные переходы никогда не выполняются, или, что любой обратный переход на
младшие адреса, является циклом и выполняется, а любой прямой переход на более старшие адреса, не выполняется.</p>

<p>Динамические методы, широко используемые в современных процессорах, подразумевают анализ истории ветвлений. При этом ведётся таблица ранее
совершенных переходов – для каждого условного перехода подсчитывается, сколько раз он “сработал”, а сколько – “был проигнорирован”. Поэтому когда МП
встречает переход, завершающий цикл, включается счётчик совершённых переходов. Если переход сработал несколько раз, то вероятнее всего этот переход
будет срабатывать и в дальнейшем, т.е. делается предсказание, что переход всегда происходит. При этом ошибочная ситуация по окончании цикла не будет
катастрофичной, т.к. ценой максимум двух ошибок обеспечивается точное предсказание во всех остальных случаях. На простых циклах процессор, как
правило, ошибается ещё реже – не более одного раза.</p>

<p>При неправильном предсказании конвейер обычно приходится “сбрасывать”, восстанавливая состояние процессора, предшествующее моменту неправильного
перехода. Для современных МП каждая ошибка предсказания – это десятки вхолостую израсходованных тактов, т.к. за каждый такт можно было бы исполнить
до трёх x86-команд и совершить множество вычислений. Если бы блока предсказания не было, то так “тормозил” бы каждый условный переход.</p>

<p>Точность предсказания современных блоков составляет порядка 98-99%. Может показаться, что совершенствовать блок не имеет смысла, но это не
совсем так. Дело в том, что на производительности гораздо больше сказывается процент ошибок, а не верных предсказаний. А переход от 98-процентной
точности к 99-процентной означает двукратное снижение ошибок – с 2% до 1%!</p>

<p>В архитектуре IA-64 техника предсказания переходов сделала значительный шаг вперед – эти процессоры умеют одновременно вычислять несколько веток
программного кода. То есть, встретив инструкцию условного перехода, процессор просчитывает оба варианта развития событий вплоть до того момента,
пока не станет ясно, какой из них правильный. Поскольку команды “разных вариантов” практически не зависят друг от друга, а исполнительные устройства
Itanium обычно загружены далеко не полностью, то исполнять побочную ветку нередко удаётся с той же скоростью, что и основную, так что даже при
неправильном предсказании условного перехода происходит не остановка процессора на пару десятков тактов, а всего лишь снижение производительности
на небольшом участке кода.</p>

<p>В суперскалярных МП используется ряд методов для ускорения вычислений, характерных прежде всего для них, однако такие методики могут
использоваться и в других типах архитектур. Это внеочередное исполнение команд, переименование регистров и объединение нескольких команд в
одну.</p><br><br>




<a name="2.11"></a><p class="h3">2.11 Кэш</p>

<p>Кэш (англ. cache) – промежуточный буфер с быстрым доступом, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. Доступ
к данным в кэше идёт быстрее, чем из ОЗУ и внешней памяти, за счёт чего уменьшается среднее время доступа и увеличивается общая производительность.
Прямой доступ к данным, хранящимся в кэше, программным путём невозможен. Физически – это память с большей скоростью доступа, предназначенная для
ускорения обращения к данным, содержащимся постоянно в памяти с меньшей скоростью доступа (далее “основная память”).</p>

<p>МП используют кэш для минимизации доступа к ОЗУ, которая медленнее, чем регистры. Он разделён на несколько уровней и может достигать 3. Кэш-память
уровня N+1 как правило больше по размеру и медленнее по скорости доступа и передаче данных, чем кэш-память уровня N.</p>

<p>Самой быстрой памятью является кэш первого уровня – L1-cache. Она является неотъемлемой частью процессора, поскольку расположена на одном с ним
кристалле и входит в состав функциональных блоков. В современных процессорах обычно кэш L1 разделен на два кэша – кэш команд и кэш данных
(Гарвардская архитектура). Большинство процессоров без L1 кэша не могут функционировать. L1 кэш работает на частоте процессора, и обращение к нему
может производиться каждый такт. Зачастую является возможным выполнять несколько операций чтения/записи одновременно. Латентность доступа обычно
равна 2..4 тактам ядра. Объём обычно невелик – не более 128 Кбайт.</p>

<p>Вторым по быстродействию является L2-cache – кэш второго уровня, обычно он расположен на кристалле, как и L1. В старых процессорах – это набор
микросхем на системной плате. Объём L2 кэша от 128 Кбайт до 1..12 Мбайт. В современных многоядерных процессорах кэш второго уровня, находясь на том
же кристалле, является памятью раздельного пользования. Обычно латентность L2 кэша, расположенного на кристалле ядра, составляет от 8 до 20 тактов
ядра.</p>

<p>Кэш третьего уровня наименее быстродействующий, но он может быть очень внушительного размера – более 24 Мбайт. L3 кэш медленнее предыдущих, но
значительно быстрее оперативной памяти. В многопроцессорных системах он находится в общем пользовании и предназначен для синхронизации данных
различных кэшей L2.</p>

<p>Существует три варианта обмена информацией между кэш-памятью различных уровней, или, как говорят, кэш-архитектуры: инклюзивная, эксклюзивная и
неэксклюзивная.</p>

<p>Инклюзивная архитектура предполагает дублирование информации кэша верхнего уровня в нижнем (предпочитает фирма Intel).</p>

<p>Эксклюзивная кэш-память предполагает уникальность информации, находящейся в различных уровнях кэша (предпочитает фирма AMD).</p>

<p>В неэксклюзивной кэши могут вести себя как угодно.</p><br><br><br>




<a name="3"></a>
<table border=0 cellpadding=0 cellspacing=0 width=97% bgcolor=#ABB3D5>
  <tr><td bgcolor=#000000 colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
  <tr><td width="30"></td><td valign=center><span class=h>Память микропроцессорных систем</span></td></tr>
  <tr><td bgcolor=#000000 width="25" colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
</table>
<br><br>

<a name="3.1"></a><p class="h3">3.1 Классификация запоминающих устройств</p>

<p>Памятью называется совокупность технических средств, предназначенных для записи, хранения и считывания информации в виде цифрового кода.
Отдельные элементы памяти получили название запоминающих устройств (ЗУ). Основная память микропроцессорной системы состоит из ЗУ двух видов: –
оперативного – ОЗУ (RAM, Random Access Memory, память с произвольным доступом) и постоянного – ПЗУ (ROM, Read Only Memory) (рис. 17).</p>

<div align="center"><img src="images/065.png" title="Классификация микросхем памяти"><br>
Рис. 17. Классификация микросхем памяти</div>

<p>Деление на оперативную и постоянную память достаточно условно. С точки зрения МП, оба эти вида памяти практически идентичны. И та, и другая
представляют собой матрицу запоминающих ячеек. В обоих типах выбор нужной ячейки производится через адресную шину подачей соответствующего кода.
Для удобства, он, как и данные, обозначается в шестнадцатеричной системе счисления. В литературе можно встретить, к примеру, 0F4CH; хотя в
современных компиляторах принято обозначение-префикс «$» либо «0x» ($45CF, либо 0x4E). Однако всё же между оперативной и постоянной памятью есть
существенное различие.</p><br><br>




<a name="3.2"></a><p class="h3">3.2 Оперативное запоминающее устройство</p>

<p>ОЗУ предназначено для хранения переменной информации, оно допускает изменение своего содержимого в ходе выполнения процессором вычислительных
операций с данными. Это значит, что процессор может выбрать из ОЗУ код команды и данные (режим чтения) и после обработки поместить в ОЗУ полученный
результат (режим записи). Причём возможно размещение в ОЗУ новых данных на месте прежних, которые в этом случае перестают существовать. При этом
различают статические (SRAM – Static Random Access Memory) и динамические (DRAM) ОЗУ. Оперативная память может представлять собой как отдельную
микросхему, так и являться частью микроконтроллера.</p>

<p>В микросхемах статических ОЗУ информация хранится в виде устойчивого состояния триггера, который способен при наличии напряжения питания
сохранять свое состояние неограниченное время. Достоинством таких ОЗУ является максимальное быстродействие, а недостатком – высокая стоимость,
низкая плотность хранения информации и значительное энергопотребление.</p>

<p>Если для создания ячейки динамической памяти достаточного всего одного транзистора и одного конденсатора, то ячейка статической памяти состоит
как минимум из четырёх, а в среднем из 6..8 транзисторов, поэтому мегабайт статической памяти оказывается по меньшей мере в несколько раз
дороже.</p>

<div align="center" style="float: right; margin-left: 20px"><img src="images/066.png" title="Триггер на логических элементах НЕ"><br>
Рис. 18. Триггер</div>

<p>Триггер состоит из двух инверторов, соединенных по типу “защёлки”. При подаче на линию Q единицы элемент DD1 проинвертирует его в ноль. Но,
поступив на вход элемента DD2 этот ноль вновь превратится в единицу. Поскольку выход DD2 подключен ко входу DD1, то даже после исчезновения сигнала
с линии Q, он будет поддерживать себя самостоятельно, т.е. триггер перейдёт в устойчивое состояние.</p>

<p>Триггеры объединяются в матрицу, состоящую из строк (row) и столбцов (column). В отличии от ячейки динамической памяти (DRAM), для управления
которой достаточно всего одного ключевого транзистора, ячейка статической  (SRAM) управляется как минимум двумя т.к. триггер имеет раздельные входы для записи “0” и “1”. Т.о. ячейка SRAM
состоит из 8 транзисторов, т.е. четырёх транзисторов триггера и двух – для управляющих “защёлок”. Матрица ЗУ на 32 Кб такой памяти имеет свыше двух
миллионов транзисторов!</p>

<div align="center"><img src="images/067.png"><br>
Рис. 19. Устройство 6-транзистроной одно-портовой ячейки SRAM-памяти</div>

<p>Недостаток 6- транзисторной ячейки состоит в невозможности параллельного чтения ячеек, расположенных в различных строках одного и того же банка,
а также невозможность чтения одной ячейки одновременно с записью другой. Этого ограничения лишена многопортовая память, 8-транзисторная ячейка
которой имеет один триггер с несколькими комплектами управляющих транзисторов, каждый из которых подключен к независимым линиям ROW и BIT.
Такой подход более удачен, чем деление памяти на банки для параллельного доступа нескольких устройств к матрице. Многопортовая память допускает
одновременную обработку любых ячеек.</p>

<div align="center"><img src="images/068.png"><br>
Рис. 20. Устройство 8-транзистроной двух портовой ячейки SRAM-памяти
</div><br>

<div align="center"><img src="images/069.png"><br>
Рис. 21. Условное графическое обозначение статической памяти<br></div>

<p>Обычно у микросхемы SRAM объединяют линии входа с выходами, а режим чтения/записи определяет вывод WE (Write Enable, ”1” – чтение, “0” – запись).
Статическая память, размещённая на кристалле МП, не мультиплексируется, чтобы содержимое одной ячейки можно было читать параллельно с записью другой
(линии входа и выхода раздельные).</p>

<p>Рассмотрим схему SRAM. Она имеет 8 матриц ячеек для каждой линии данных. Это позволяет иметь байтовую архитектуру микросхемы. Номера столбцов и
строк поступают на декодеры столбца и строки соответственно. После декодирования расшифрованный номер строки поступает на дополнительный декодер,
вычисляющий, принадлежащую ей матрицу. Оттуда он попадает непосредственно на выборщик строки, который открывает "защелки" требуемой страницы. В
зависимости от режима работы чтение / запись чувствительный усилитель битовых линеек матрицы, либо считывает состояние триггеров соответствующей
raw-линейки, либо записывает в них информацию.</p>

<div align="center"><img src="images/070.png"><br>
Рис. 22. Устройство типовой микросхемы SRAM-памяти</div>

<p>При чтении сигнал CS сбрасывается в 0, давая понять тем самым микросхеме, что микросхема "выбрана" и сейчас с ней будут работать. К
моменту стабилизации сигнала SC, на адресных линиях должен находиться адрес ячейки (т.е. номер строки и номер столбца), а сигнал WE должен быть
переведён в высокое состояние (чтение). Спустя время (tAddress Access), определяемое быстродействием управляющей логики и быстротечностью переходных процессорах
в инверторах, на линиях выхода появляются, которые вплоть до окончания рабочего цикла (tCycle) могут быть непосредственно считаны. Обычно время
доступа к ячейке статической памяти не превышает 1 - 2 нс., а зачастую бывает и меньше того!</p>

<p>Цикл записи происходит в обратном порядке.</p>

<p>В микросхемах динамических ОЗУ (DRAM, Dynamic Random Access Memory) элементы памяти выполнены на основе
конденсаторов, сформированных в виде матрицы. Такие элементы памяти не могут долгое время сохранять свое состояние, определяемое наличием или
отсутствием электрического заряда, и поэтому нуждаются в периодическом обновлении (регенерации). Микросхемы динамических ОЗУ отличаются от
статических гораздо большей информационной емкостью, что обусловлено меньшим числом компонентов в одном элементе памяти и, следовательно, более
плотным их размещением в полупроводниковом кристалле. Однако динамические ОЗУ сложнее в применении, поскольку нуждаются в организации принудительной
регенерации и в усложнении устройств управления. Динамическая память имеет среднее быстродействие и невысокую стоимость.</p>

<div align="center" style="float: right; margin-left: 20px"><img src="images/DRAM_02.png" title="Динамическая память DRAM"><br>
Рис. 23. Динамическая память DRAM</div>

<p>На физическом уровне ячейки DRAM объединены в матрицу c горизонтальными строками (ROW) и вертикальными столбцами (Column) или
страницами (Page). Линейки представляют собой проводники, на пересечении которых находится конденсатор и транзистор, удерживающий конденсатор
от разряда. Обычно транзистор закрыт, но при подаче на соответствующую строку матрицы сигнала, он откроется, соединяя обкладку конденсатора с
соответствующим ей столбцом. Усилитель чтения, подключенный к каждому из столбцов матрицы считывает всю страницу целиком, поэтому именно страница
является минимальной порцией обмена с данными. Чтение/запись отдельно взятой ячейки невозможно, так как открытие строки открывает все подключенные
к ней транзисторы, а, следовательно, – разряду закрепленных за этими транзисторами конденсаторов.</p>

<p>Чтение ячейки деструктивно по своей природе, поскольку усилитель разряжает конденсаторы в процессе считывания заряда. Потому во избежание потери
информации считанную строку приходится тут же перезаписывать вновь. Эту операцию выполняет либо контроллер, либо сама микросхема памяти.</p>

<p>Интерфейс схемы DRAM имеет линии адреса и линии данных. Режим записи/чтения определяется состоянием вывода Write Enable. Низкий уровень – чтение.
Линии адреса мультиплексированы, так как на высоких частотах сказывается влияние длины проводников, иначе сигнал от одного вывода будет опережать
сигнал от другого. Во-вторых, длины проводников не должны быть очень велики – в противном случае задержка распространения сигнала нивелирует всё
быстродействие. В-третьих, любой проводник действует как приёмная и как передающая антенна, причём уровень помех резко усиливается с ростом тактовой
частоты. Паразитному антенному эффекту можно противостоять множеством способов, но самым радикальным остается сокращение количества проводников и
уменьшение их длины. Наконец, в-четвёртых, всякий проводник обладает электрической ёмкостью, а ёмкость и высокая скорость передачи данных –
несовместимы.</p>

<p>В случае квадратной матрицы количество адресных линий сокращается вдвое, но и выбор ячейки памяти занимает вдвое больше тактов, ведь номера
столбца и строки приходится передавать последовательно. При выборке ячейки контроллер выдаёт номер строки, сопровождаемый сигналом RAS (Row
Address Strobe), который подаётся на соответствующую строку матрицы. Все транзисторы, подключенные к этой строке, открываются и бурный поток
электронов, срываясь с насиженных обкладок конденсаторов, устремляется на входы усилителя чтения. Он декодирует всю строку, и сохраняет полученную
информацию в специальном буфере. Всё это занимает 20..100нс., в течение которых контроллер памяти выдерживает паузу. Затем контроллер
выдаёт номер колонки, сопровождаемый сигналом CAS (Column Address Strobe). Микросхема преобразует номер колонки в смещение ячейки внутри
буфера. Остается всего лишь прочесть её содержимое и выдать его на линии данных. Это занимает ещё какое-то время, в течение которого контроллер ждёт
запрошенную информацию. На финальной стадии цикла обмена контроллер считывает состояние линий данных, дезактивирует сигналы RAS и CAS, устанавливая
их в высокое состояние, а микросхема берёт определённый тайм-аут на перезарядку внутренних цепей и восстановительную перезапись строки.</p>

<p>Появление микропроцессоров с шинами на 100 MHz привело к радикальному пересмотру механизма управления памятью, и подтолкнуло конструкторов к
созданию синхронной динамической памяти – SDRAM (Synchronous-DRAM). Микросхемы SDRAM работают синхронно с контроллером, что гарантирует
завершение цикла в строго заданный срок. Кроме того, номера строк и столбцов подаются одновременно, чтобы к приходу следующего тактового импульса
сигналы уже успели стабилизироваться и были готовы к считыванию.</p>


<p>Так же, в SDRAM реализован усовершенствованный пакетный режим обмена. Контроллер может запросить как одну, так и несколько последовательных ячеек
памяти, а при желании - всю строку целиком! Это стало возможным благодаря использованию полноразрядного адресного счётчика. Количество матриц
(банков) памяти в SDRAM увеличено с одного до двух (а, в некоторых моделях, и четырёх), что позволяет обращаться к ячейкам одного банка параллельно
с перезарядкой внутренних цепей другого, что вдвое увеличивает предельно допустимую тактовую частоту. Помимо этого появилась возможность
одновременного открытия двух (четырех) страниц памяти, причем открытие одной страницы (т.е. передача номера строки) может происходить во время
считывания информации с другой, что позволяет обращаться по новому адресу столбца ячейки памяти на каждом тактовом цикле.</p>

<p>DDR SDRAM (Double Data Rate SDRAM) SDRAM с удвоенной скоростью передачи данных. Удвоение скорости достигается за счёт передачи
данных и по фронту, и по спаду тактового импульса (в SDRAM передача данных осуществляется только по фронту). Благодаря этому эффективная частота
увеличивается в два раза - 100 MHz DDR-SDRAM по своей производительности эквивалента 200 MHz SDRAM. Каждый банк памяти имеет персональный контроллер
(не путать с контроллером памяти!), в результате чего вместо одной микросхемы мы получили как бы четыре, работающих независимо друг от друга.
Соответственно, максимальное количество ячеек, обрабатываемых за один такт, возросло с одной до четырёх. Аналогичный подход применяется и в
современных типах пямяти - DDR3, DDR4 и DDR5.</p>

<div align="center">
<table>
  <tr> <td><img src="images/073.png" title="Временная диаграмма SDRAM"></td> <td colspan="2"><img src="images/DDR2.png"> </tr>
  <tr valign=bottom align=center> <td>а</td> <td>б</td></tr>
</table>
Рис. 25.  Синхронная память:<br>
а – временная диаграмма работы; б – организация SDRAM, DDR и DDR2</div>

<p>Таким образом, ОЗУ может работать в режимах записи, считывания и хранения информации.</p><br><br>




<a name="3.3"></a><p class="h3">3.3 Постоянное запоминающее устройство</p>

<p>ПЗУ содержит информацию, которая не изменяется в ходе выполнения процессором программы и должна храниться при выключенном источнике питания.
Такую информацию составляют стандартные подпрограммы, табличные данные, коды физических констант, постоянных коэффициентов и т.п. Эта информация
заносится в ПЗУ предварительно, например, путём пережигания легкоплавких металлических перемычек в структуре ПЗУ, и в ходе работы, процессора может
только считываться.</p>

<p>Существует разновидность ПЗУ, допускающая неоднократное (сотни тысяч циклов) перепрограммирование (репрограммирование). Элементом памяти в
репрограммируемых ПЗУ (РПЗУ, PROM) является МДП-транзистор, обладающий свойством переходить в состояние проводимости под воздействием импульса
программирующего напряжения и сохранять это состояние длительное время. Данный эффект обусловлен накоплением электрического заряда в подзатворном
диэлектрике. Для стирания информации перед новым циклом программирования необходимо вытеснить накопленный под затвором заряд. В зависимости от
способа выполнения этой операции микросхемы РПЗУ разделяют на два вида: со стиранием ультрафиолетовым светом (УФ РПЗУ) и со стиранием электрическим
сигналом (ЭС РПЗУ, EEPROM, или Flash-память). Флэш-технология позволяет оснастить системную память уникальными свойствами. Подобно ОЗУ, флэш-память
модифицируется электрически внутрисистемно, но, подобно ПЗУ, флэш энергонезависима и хранит данные даже после отключения питания. Однако в отличие
от ОЗУ флэш нельзя переписывать побайтно: её нужно стереть перед записью новых данных.</p>

<p>Микросхемы флэш-памяти в последнее время получили большое распространение ввиду высоких потребительских качеств – простоты программирования,
высокой скорости чтения и значительной ёмкости. Параметрические блоки флэш-памяти используются для хранения телефонных номеров, учёта времени
использования и идентификатора пользователя (SIM-карта) в сотовых телефонах. Производители автомобилей используют флэш-память в системах управления
двигателями для хранения кодов ошибок и параметров оптимальных режимов работы. В каждом из подобных примеров изготовители экономят на расходах,
связанных с необходимостью содержания складского запаса «прошитых» разными программами ПЗУ, используя флэш-память не только для хранения прикладных
программ, но и параметров.</p>

<p>Следует отметить, что существует две разновидности флэш-памяти. Первая используется для хранения программ и имеет ёмкость порядка 1 Мбайт;
вторая, – NAND EEPROM используется, в основном, в качестве мобильного носителя данных, имеет последовательный доступ к данным и ёмкость в десятки
Гбайт! Таким образом, ПЗУ работает в режимах хранения и считывания.</p>

<p>Запоминающее устройство, реализующее функции основной памяти, размещают рядом с процессором в одном блоке, и такое ЗУ в этом смысле является
внутрисистемным. Быстродействие внутреннего ЗУ должно быть соизмеримо с быстродействием процессора. Однако практически это требование не всегда
удаётся выполнить: по временным параметрам ОЗУ и ПЗУ отстают от процессора. Поэтому внутри ЭВМ обычно размещают еще и вспомогательную (буферную)
память на быстродействующих регистрах, которая используется в качестве сверхоперативного ЗУ (СОЗУ или Cache) с небольшой информационной ёмкостью
для кратковременного хранения текущих команд, адресов и данных.</p>

<p>Важнейшими характеристиками ЗУ являются:</p>

<ul>
  <li>ёмкость, удельная ёмкость;</li>
  <li>быстродействие;</li>
  <li>энергопотребление;</li>
  <li>способность сохранять информацию при отключении питания.</li>
</ul>

<p>Информационная ёмкость определяет число единиц информации в битах или байтах, которое БИС памяти может хранить одновременно. Она выражается через
число ячеек N c указанием разрядности n в виде M = N × n. Удельная ёмкость – отношение информационной ёмкости к её физическому объёму.
Быстродействие, как правило, характеризуется двумя параметрами:</p>

<p>1. Время выборки (t<sub>в</sub>) – представляет интервал времени между передачей сигнала «выборка кристалла» (CS) при считывании информации и
появлением информации на шине данных,</p>

<p>2. Время цикла записи (t<sub>цз</sub>), которое определяется минимально возможным временем с момента подачи сигнала CS при записи и повторном
обращении к памяти.</p>

<p>В качестве характеристики быстродействия памяти выбирается максимальное из t<sub>в</sub> и t<sub>цз</sub>.</p><br><br>




<a name="3.4"></a><p class="h3">3.4 Память как функциональный узел</p>

<p>Рассмотрим микросхему памяти как «чёрный ящик», обратив основное внимание на назначение её выводов, внешние и внутренние характеристики. На
рис. 25 приведены графические изображения ОЗУ и ПЗУ.</p>

<div align="center"><img src="images/069.png"> <img src="images/074.png"><br>
Рис. 25. Условные обозначения микросхем ОЗУ (RAM) и ПЗУ (ROM)</div>

<p>Сигналы и соответствующие выводы можно подразделить на адресные, управляющие и информационные. Количество адресных входов A0 – A11 позволяет
определить информационную ёмкость микросхемы: 2<Sup>11</Sup> = 2048 адресуемых ячеек памяти. Наличие восьми информационных выводов указывает на
восьмиразрядную организацию каждой ячейки. Поэтому общий объём памяти составляет 2048 × 8 бит = 2 Кбайт. Для управления режимом работы
предусмотрены три сигнала: W/R – чтение/запись (Write/Read), CS – выбор микросхемы (Chip Select) и OE – разрешение выходов (Output Enable). Для
обращения к микросхеме для записи или считывания одного байта информации необходимо подать сигнал CS с нулевым уровнем (разрешающий обращение) и
сигнал W/R с соответствующим режиму уровнем: при записи – 1, при считывании – 0. Для упрощения дешифрации микросхемы памяти могут иметь несколько
входов CS. Входы-выходы D совмещены, поэтому они обладают свойством двунаправленной проводимости. Отметим, что все операции чтения записи возможны
только при низком активном уровне на входе OE. В противном случае шина данных переключается в высокоомное состояние, что равносильно её
отключению.</p><br><br>




<a name="3.5"></a><p class="h3">3.5 Многомодульная организация памяти</p>

<p>Механизм взаимодействия процессора с памятью основан на классической архитектуре вычислительной системы, состоящей из трёх основных компонентов:
процессора, памяти и устройств ввода/вывода, объединённых шинами данных, адреса и управления (рис. 26).</p>

<div align="center"><img src="images/075.gif"><br>
Рис. 26. Взаимодействие процессора и памяти</div>

<p style="margin-top: 20px">В простейшем случае в процессе работы программы МП выдаёт на адресную шину адрес требуемой ячейки памяти, сопровождаемый
сигналом чтение/запись шины управления, а память извлекает или сохраняет информацию, находящуюся на шине данных. При обмене информацией с памятью
ведущим является микропроцессор либо контроллер прямого доступа к памяти. При этом возникает проблема согласования быстродействия МП и памяти.
Обычно процессор более быстродействующий, чем остальные компоненты, поэтому, чтобы согласовать временные параметры всех подсистем, применяются два
способа:</p>

<p>1) синхронный, при котором между выдачей адреса и передачей данных производится фиксированная задержка (целое число тактов);</p>

<p>2) асинхронный, при котором после приема адреса и его дешифрации память отвечает процессору сигналом «Готовность».</p>

<p>На рис. 27 представлен пример построения и взаимодействие микропроцессора и памяти, состоящей из ОЗУ и ПЗУ одинаковой ёмкости и одинаковой
организации 16К × 8бит. Известно, что процессор КР580ВМ80А с помощью шестнадцати адресных линий может адресовать 2<Sup>16</Sup> = 64 Кбайт памяти.
Организуем её таким образом, чтобы её первая половина (32 Кбайт) была отведена под ОЗУ, а вторая (32 Кбайт) – под ПЗУ. При этом всё адресное
пространство оказывается разделённым на четыре банка (две микросхемы ОЗУ и две микросхемы ПЗУ по 16 Кбайт каждая).</p>

<p>При обмене информацией процессор выставляет на адресной шине 16-разрядный адрес ячейки памяти, который сопровождается сигналом «чтение/запись».
Четырнадцать младших разрядов адреса (A0-A13) непосредственно подключены к соответствующим входам микросхем памяти, а две старшие адресные линии
A14 и A15 определяют номер банка. Микросхема-дешифратор посредством сигнала CS (выбор кристалла) позволяет выбрать положение микросхемы ЗУ в
адресном пространстве. Для данного случая это адреса 0000h-7FFFh для ОЗУ и 8000h-FFFFh для ПЗУ.</p>

<div align="center"><img src="images/076.png"><br>
Рис. 27. Многомодульная организация памяти</div>

<p style="margin-top: 20px">В некоторых микропроцессорах (рис. 28) шина адреса и шина данных совмещается (мультиплексируется). В этом случае шина
сначала используется для передачи адреса, а затем по ней передаются данные. При этом адрес запоминается во внешнем регистре, который стробируется
специальным сигналом разрешения захвата адреса ALE.</p>

<div align="center"><img src="images/077.png"><br>
Рис. 28. Мультиплексирование шин</div>

<p style="margin-top: 20px">Аналогичный приём (совмещение шин адреса и данных) используется в большинстве современных микроконтроллеров.</p>
<br><br><br>




<a name="4"></a>
<table border=0 cellpadding=0 cellspacing=0 width=97% bgcolor=#ABB3D5>
  <tr><td bgcolor=#000000 colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
  <tr><td width="30"></td><td valign=center><span class=h>Архитектура МК AVR</span></td></tr>
  <tr><td bgcolor=#000000 width="25" colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
</table>
<br>


<a name="4.1"></a><p class="h3">4.1 Вычислительное ядро AVR</p>

<p>Архитектура AVR-микроконтроллеров базируется на гарвардском RISC-процессоре с раздельным доступом к памяти программ и памяти данных. Он имеет 32
РОН, каждый из которых может работать как регистр-аккумулятор, и развитую систему команд фиксированной 16-бит длины. Большинство команд выполняются
за один машинный такт с использованием многоуровневой конвейерной обработки и с одновременным исполнением текущей и выборкой следующей команды. Это
обеспечивает производительность до 1 MIPS на каждый МГц тактовой частоты. При этом ядро имеет статическую организацию (минимальная частота может
быть равна 0), а при максимальной тактовой частоте 20 МГц обеспечивается производительность до 20 миллионов операций в секунду. На рис. 29
приведены диаграммы выполнения команд конвейером AVR.</p>

<div align="center"><img src="images/106.png" title="Диаграмма выполнения"> <img src="images/107.png" title="Диаграмма выполнения"><br>
Рис. 29. Диаграммы выполнения команд конвейером AVR</div>

<p style="margin-top: 20px">32 РОН (R0..R31) образуют регистровый файл быстрого доступа, где каждый регистр напрямую связан с АЛУ. За один такт из
регистрового файла выбираются два операнда, выполняется операция, и результат возвращается в регистровый файл. АЛУ поддерживает арифметические и
логические операции с регистрами, между регистром и константой или непосредственно с регистром. Старшие микроконтроллеры ATmega имеют в составе АЛУ
аппаратный умножитель.</p>

<p>Большинство команд, оперирующих РОН, имеет прямой доступ ко всем его регистрам. Как показано на рис. 30, каждому регистру также соответствует
адрес в пространстве памяти данных, где они занимают первые 32 ячейки. Хотя физически регистры не входят в ОЗУ, такая организация памяти
обеспечивает большую гибкость при доступе к регистрам.</p>

<div align="center"><img src="images/043.png" title="Регистры"><br>
Рис. 30. Регистры общего назначения микроконтроллеров AVR</div>

<p style="margin-top: 20px">Регистры R26..R31 могут использоваться как три 16-разрядных регистра-указателя косвенной адресации X, Y, Z (рис. 31).
Один из этих регистров-указателей может также использоваться в качестве указателя адреса данных, размещенных в памяти программ (Flash-памяти).</p>

<div align="center"><img src="images/044.png" title="Регистры X, Y, Z"><br>
Рис. 31. Сдвоенные регистры X, Y, Z</div>

<p style="margin-top: 20px">В командах с косвенной адресацией, эти регистры используются как источники постоянного адреса, как адресный регистр с
автоматическим приращением адреса либо как регистр с автоматическим уменьшением адреса.</p>

<p>МК AVR имеют встроенную постоянную память программ с возможностью внутрисхемного программирования через последовательный 4-проводной интерфейс.
Периферия МК AVR включает: таймеры-счётчики, широтно-импульсные модуляторы, поддержку внешних прерываний, аналоговый компаратор, 10-разрядный
8-канальный АЦП, параллельные порты (от 3 до 53 линий ввода и вывода), интерфейсы UART и SPI, сторожевой таймер и устройство сброса по включению
питания (рис. 32).</p>

<div align="center"><img src="images/045.png" title="Блок схема МК"><br>
Рис. 32. Упрощённая блок-схема МК AVR</div>

<p style="margin-top: 20px">Поддерживается спящий режим и режим микропотребления. В спящем режиме останавливается центральное процессорное ядро, в
то время как регистры, таймеры-счётчики, сторожевой таймер и система прерываний продолжают функционировать. В режиме микропотребления сохраняется
содержимое всех регистров, останавливается тактовый генератор, запрещаются все функции микроконтроллера, пока не поступит сигнал внешнего прерывания
или аппаратного сброса. В зависимости от модели, AVR-микроконтроллеры работают в диапазоне напряжений 2,7..6 В либо 4..6 В (исключение составляет
ATtiny12V с напряжением питания 1,2 В).</p>

<p>Блок-схема одного из простых микроконтроллеров AVR ATtiny2313 приведена на рис. Она имеет следующие характеристики:</p>

<ul>
  <li>2 Кбайт системной программируемой Flash-памяти программ;</li>
  <li>128 байт EEPROM;</li>
  <li>128 байт SRAM (ОЗУ);</li>
  <li>18 линий ввода-вывода (I/O);</li>
  <li>однопроводной интерфейс для внутрисхемной отладки;</li>
  <li>два многофункциональных таймера/счётчика с функцией совпадения;</li>
  <li>поддержка внешних и внутренних прерываний;</li>
  <li>последовательный программируемый USART-порт;</li>
  <li>универсальный последовательный интерфейс с детектором начала передачи;</li>
  <li>программируемый сторожевой таймер с внутренним генератором;</li>
  <li>три программно изменяемых режима энергосбережения.</li>
</ul>

<div align="center"><img src="images/046.gif" title="Блок схема микроконтроллера"><br>
Рис. 33. Блок-схема микроконтроллера ATtiny2313</div>
<br><br>




<a name="4.2"></a><p class="h3" style="margin: 20px 0;">4.2 Регистр статуса</p>

<p>Последовательность выполнения программы может быть изменена командами условного и безусловного перехода, а также командой вызова подпрограммы, в
которых используется непосредственная адресация. Команды условного перехода используют <b>регистр статуса (флагов) SREG</b>, который содержит
информацию о результатах выполнения последней арифметической или логической команды. Изменение регистра статуса происходит не только при выполнении
команд сравнения, но также в результате действия любых других команд, связанных с АЛУ.</p>

<p>При вызове процедуры обработки прерывания регистр статуса автоматически не сохраняется. Программист должен обязательно предусмотреть в процедуре
обработки прерываний команды, которые будут сохранять содержимое этого регистра в начале и восстанавливать его в конце. Регистр статуса не может
быть непосредственно помещен в стек. Сначала необходимо сохранить в стеке один из РОН, затем поместить в освободившийся регистр содержимое регистра
статуса, а затем уже из этого промежуточного регистра переместить информацию в стек.</p>

<p>Регистр статуса микроконтроллера SREG имеет следующий формат:</p>

<div align="center"><img src="images/082.png" title="Регистр статуса SREG"><br>
Рис. 34. Регистр статуса SREG</div>

<p style="margin-top: 20px"><b>Бит 7 – I (Interrupt): Общее разрешение прерываний.</b> При установке этого флага в единичное состояние разрешается
работа всей системы прерываний. Отдельные виды прерываний включаются и выключаются при помощи дополнительных регистров конфигурации. Флаг I
аппаратно сбрасывается сразу после вызова соответствующей процедуры обработки прерывания и устанавливается при выполнении команды
<code style="color: #005599">reti</code>, разрешая последующие прерывания.</p>

<p><b>Бит 6 – Т: Пользовательский бит для временного хранения информации.</b> Бит Т используется командами <code style="color: #005599">bld</code>
(загрузка бита Т) и <code style="color: #005599">bst</code> (чтение бита Т) как ячейка для временного хранения информации. Любой бит любого регистра
общего назначения может быть скопирован в Т, а затем содержимое Т может быть скопировано в любой другой бит того же либо любого другого
регистра.</p>

<p><b>Бит 5 – Н (Half): Флаг полупереноса.</b> Этот флаг устанавливается в единицу, если имел место перенос из младшей половины байта (из 3-го
разряда в 4-й) или заем из старшей половины байта при выполнении некоторых арифметических операций.</p>

<p><b>Бит 4 – S (Sign): Флаг знака</b>, S = N &oplus; V. Этот флаг является результатом операции «Исключающее ИЛИ» между флагами N (отрицательный
результат) и V (переполнение числа в дополнительном коде). Соответственно, этот флаг устанавливается в единицу, если результат выполнения
арифметической операции меньше нуля.</p>

<p><b>Бит 3 – V (oVerflow): Флаг переполнения дополнительного кода.</b> Этот флаг используется при работе со знаковыми числами (числами,
представленными в дополнительном коде). Флаг устанавливается в единицу, если в результате арифметической операции произойдет переполнение числа,
представленного в дополнительном коде. V = 1, если старший бит результата не может быть интерпретирован как знаковый (например, при суммировании
положительных чисел получен отрицательный результат), т.е. дополненный до двух результат со знаком не вписывается в количество битов, используемых
для операции.</p>

<p>Флаг переполнения устанавливается, когда старший знаковый бит изменяется в результате сложения двух чисел с одинаковым знаком (или вычитания двух
чисел с противоположными знаками). Показательным примером может служить сложение 127 и 127 с использованием 8-битных регистров. 127 + 127 = 254, но
с использованием 8-битных регистров результат будет 11111110<sub>2</sub>, который равен -2<sub>10</sub> в виде дополнения до двух и таким образом
отрицательный. Т.е. в результате сложения двух положительных операндов получили отрицательный результат – произошло переполнение и изменение знака
числа.</p>

<p style="text-align: center; font-weight: bold; ">Формирование флагов C и V при сложении:</p>
<div style="text-align: center;">
    <div style="display: inline-block; margin: 0 20px;">
        <p>FF<sub>16</sub> + FF<sub>16</sub> = FE<sub>16</sub></p>
        <p>(-1) + (-1) = (-2)</p>
        <p>C=1, V=0</p>
    </div>
    <div style="display: inline-block; margin: 0 20px;">
        <p>7F<sub>16</sub> + 7F<sub>16</sub> = FE<sub>16</sub></p>
        <p>(+127) + (+127) = (-2)</p>
        <p>C=0, V=1</p>
    </div>
    <div style="display: inline-block; margin: 0 20px;">
        <p>01<sub>16</sub> + 01<sub>16</sub> = 02<sub>16</sub></p>
        <p>(+1) + (+1) = (+2)</p>
        <p>C=0, V=0</p>
    </div>
    <div style="display: inline-block; margin: 0 20px;">
        <p>81<sub>16</sub> + 81<sub>16</sub> = 02<sub>16</sub></p>
        <p>(-127) + (-127) = (+2)</p>
        <p>C=1, V=1</p>
    </div>
</div>
<p style="text-align: center; font-weight: bold;">Формирование флагов C и V при вычитании:</p>
<div style="text-align: center;">
    <div style="display: inline-block; margin: 0 20px;">
        <p>FF<sub>16</sub> - 01<sub>16</sub> = FE<sub>16</sub></p>
        <p>(-1) - (+1) = (-2)</p>
        <p>C=0, V=0</p>
    </div>
    <div style="display: inline-block; margin: 0 20px;">
        <p>7F<sub>16</sub> - 81<sub>16</sub> = FE<sub>16</sub></p>
        <p>(+127) - (-127) = (-2)</p>
        <p>C=1, V=1</p>
    </div>
    <div style="display: inline-block; margin: 0 20px;">
        <p>01<sub>16</sub> - FF<sub>16</sub> = 02<sub>16</sub></p>
        <p>(+1) - (-1) = (+2)</p>
        <p>C=1, V=0</p>
    </div>
    <div style="display: inline-block; margin: 0 20px;">
        <p>81<sub>16</sub> - 7F<sub>16</sub> = 02<sub>16</sub></p>
        <p>(-127) - (+127) = (+2)</p>
        <p>C=0, V=1</p>
    </div>
</div>

<p style="margin-top: 20px">Таким образом флаг V следует учитывать при арифметических операциях, где используются числа со знаком, и не допускать
переполнения дополнительного кода.</p>

<p><b>Бит 2 – N (Negative): Флаг отрицательного значения.</b> Этот флаг устанавливается в единицу, если в результате арифметической операции старший
разряд результата равен единице. Если старший разряд результата вычислений равен нулю, то флаг N тоже равен нулю.</p>

<p><b>Бит 1 – Z (Zero): Флаг нуля.</b> Этот флаг устанавливается в единицу, если результат выполняемой операции равен нулю.</p>

<p><b>Бит 0 – С (Carry): Флаг переноса.</b> Этот флаг индицирует переполнение результата (перенос в старший разряд) при выполнении арифметической
операции. Кроме того, флаг переноса используется в операциях сдвига.</p>

<p>Флаги, кроме автоматической установки, можно устанавливать и сбрасывать вручную. Для этого есть команды

<p><code style="color: #005599">se*</code> для установки</p>

<p><code style="color: #005599">cl*</code> для сброса.</p>

<p>Вместо звёздочки подставляется нужный флаг, например, <code style="color: #005599">cli</code> – запрет прерываний.</p>
<br><br>




<a name="4.3"></a><p class="h3">4.3 Организация памяти</p>

<p>Память МК AVR построена по гарвардской архитектуре и разделена на две области: память данных и память программ. Кроме того, семейство ATmega
содержит ЭСППЗУ для энергонезависимого хранения данных. Все три области расположены в независимых адресных пространствах.</p>

<p>Программируемая флэш-память программ в зависимости от модификации имеет объём от 4 до 256 кБайт и 16-разрядную организацию. Поэтому 16-разрядный
счётчик команд РС у ATmega позволяет адресовать пространство до 64Кслов (слово представляет собой два байта). Логически память программ разделена на
область загрузчика, прикладной программы и область таблицы векторов прерываний. Каждая ячейка памяти программ может хранить 16-битную команду или
половину 32-битной. Память программ может быть перепрограммирована при помощи ISP-интерфейса без извлечения микроконтроллера из платы и
характеризуется износостойкостью не менее 10000 циклов запись/стирание.</p>

<div align="center"><img src="images/047.png" title="Карта памяти"><br>
Рис. 35. Карта памяти</div>

<p style="margin-top: 20px">Статическая память данных разделена на три части: файл регистров общего назначения, регистры ввода-вывода и ОЗУ.
Пространство регистров ввода-вывода содержит 64 адреса для регистров управления периферийными устройствами, режимами работы процессора и другими
функциями ввода/вывода. К любому регистру ввода-вывода можно получить доступ непосредственно по его номеру или как к ячейке памяти данных. В
адресном пространстве памяти данных регистры ввода-вывода располагаются сразу после файла регистров общего назначения (0x20..0x5F) рис. 36.</p>

<div align="center"><img src="images/048.png" title="Регистры ввода/вывода"><br>
Рис. 36. Регистры ввода/вывода</div>

<p style="margin-top: 20px">Внутренняя оперативная статическая память имеет байтовый формат и используется для оперативного хранения данных. Её
размер – от 64Байт до 4КБайт. Для некоторых моделей МК возможно подключение внешнего ОЗУ до 64К.</p>

<p>Для долговременного хранения различной информации, которая может изменяться в процессе функционирования микроконтроллерной системы, используется
энергонезависимая память данных (EEPROM) объёмом от 64Байт до 8КБайт. Этот тип памяти, доступный программе микроконтроллера непосредственно в ходе
её выполнения, удобен для хранения промежуточных данных, различных констант, коэффициентов, серийных номеров, ключей и т.п. Число циклов
стирание/запись – не менее 100 тыс. Доступ к EEPROM осуществляется через специальные регистры, расположенные в пространстве ввода/вывода.</p>
<br><br>




<a name="4.4"></a><p class="h3">4.4 Методы адресации</p>

<p>Для взаимодействия различных модулей в микроЭВМ должны быть средства идентификации ячеек внешней и внутренней памяти, регистров и портов
ввода/вывода. Поэтому каждой из запоминающих ячеек присваивается адрес, т.е. однозначная комбинация бит. Количество бит определяет число
идентифицируемых ячеек. Обычно ЭВМ имеет различные адресные пространства памяти и регистров МП, а иногда – отдельные адресные пространства
регистров, устройств ввода/вывода и внутренней памяти. Кроме того, память хранит как данные, так и команды. С другой стороны, при разработке
микропроцессоров стараются использовать коды операций минимальной длины, что приводит к возникновению проблемы идентификации данных из-за короткого
машинного слова. Поэтому для ЭВМ разработано множество способов обращения к памяти, называемых методами адресации.</p>

<p><i>Метод адресации памяти</i> – это процедура преобразования адресной информации об операнде в его исполнительный адрес. <i>Команда</i> – это
машинный код, который определяет операцию и указывает на данные.</p>

<p><b>Формат команды</b> определяет её структурные элементы, каждый из которых интерпретируется опредёленным образом при выполнении команд. Среди
таких элементов (полей) выделяют:</p>

<ul>
 <li>код операции, определяющий выполняемое действие</li>
 <li>адрес ячейки памяти, регистра процессора, внешнего устройства;</li>
 <li>режим адресации;</li>
 <li>операнд при использовании непосредственной адресации;</li>
 <li>код анализируемых признаков для команд условного перехода.</li>
</ul>

<p>Почти во всех форматах команд первые биты отводятся для кода операции (КОП). Вторая, адресная часть команды с адресным кодом в разных МП сильно
отличается.</p>

<div align="center"><img src="images/049.png" title="Общий формат команды"><br>
Рис. 37. Общий формат команды</div>

<p style="margin-top: 20px">Код операции обозначает выполняемое действие. После него в команде следует адресная область операнда/операндов с
которым/которыми необходимо выполнить операцию. Чаще всего в командах указывают адреса регистров, т.к. они находятся в самом процессоре, и доступ к
ним осуществляется с максимальной скоростью. В <b>многоадресных</b> командах адресная область может состоять из нескольких частей. При этом первых
двух частях располагаются адреса операндов, а в третьей будет записан адрес результата действия над операндами. В <b>двухадресных</b> командах
адресная область состоит из двух полей: поле адреса первого операнда и поле адреса второго операнда. Адрес результата действия над операндами будет
записан в первое поле.</p>

<div align="center"><img src="images/050.png" title="Формат двухадресной команды"><br>
Рис. 38. Формат двухадресной команды</div>

<p style="margin-top: 20px">В <b>одноадресных</b> командах адресная область состоит из одного поля, с адресом операнда, а адрес второго операнда и
результата совпадает с сумматором. Существуют так же и <b>безадресные</b> команды, которые применяются при работе со стеком. Часто в программах
операнды могут располагаться не в регистрах, а в различных ячейках памяти. В этом случае команда снабжается адресом, по которому МП может найти
нужные операнды.</p>

<div align="center"><img src="images/051.gif" title="Формат команды с непосредственным операндом"><br>
Рис. 39. Формат команды с непосредственным операндом</div>

<p style="margin-top: 20px">При <b>непосредственной адресации</b> вместо адреса операнда в команде указывается сам операнд (правда, если он
представляет целое число). При этом процессору уже нет необходимости обращаться снова к памяти за самим операндом, – он передаётся вместе с КОП.</p>

<p>Если в команде указан полный адрес ячейки, где располагаются операнды, то это уже <b>прямой (абсолютный)</b> тип адресации.</p>

<div align="center"><img src="images/052.png" title="Формат команды с прямой адресацией"><br>
Рис. 40. Формат команды с прямой адресацией</div>

<p style="margin-top: 20px">Кроме этого, в поле адреса операнда может быть указан адрес или регистра или ячейки памяти, в которой лежит тоже адрес,
по которому можно найти ячейку с нужным операндом.</p>

<div align="center"><img src="images/053.png" title="Формат команды с косвенной адресацией"><br>
Рис. 41. Формат команды с косвенной адресацией</div>

<p style="margin-top: 20px">Такой способ адресации называться <b>косвенным</b>. При косвенной адресации количество ячеек с адресами других ячеек
может быть несколько (цепочка). Количество звеньев (или ступеней перехода) называется глубиной косвенной адресации.</p>

<p>Все выше приведённые типы адресации касались одного операнда. При работе с несколькими операндами, или иначе говоря массивами, обычно
указывается адрес массива и номер (индекс) элемента. Базовый (начальный) адрес указывается в команде. Кроме этого, в команде, есть поле с номером
регистра, в котором находится значение индекса или номер ячейки в массиве относительно начального адреса. Тогда адрес каждой ячейки массива
вычисляется из суммы начального адреса и того, что содержит указанный регистр. Это называется модификацией адресов. Кроме того, существует тип
адресации, когда в регистре находится начальный адрес. В команде указан адрес этого регистра, а так же записано смещение относительно начального
адреса. Все остальные адреса операндов будут получены из суммы адреса и смещения. Такой тип адресации называется <b>относительным</b>.</p>

<p>При относительной адресации можно ещё и модифицировать адреса. В этом случае адрес будет равен сумме начального адреса плюс смещение плюс
содержимое индексного регистра.</p>

<p>Если МП использует несколько типов адресации, то в команде записывается, какой способ будет применён в данный момент, т.е. в команде указывается
признак адресации в поле признака операции.</p>

<p>Таким образом, в большинстве случаев фактическое обращение к данным происходит по физическому (исполнительному) адресу. Обычно физический адрес
не совпадает с адресным полем команды, но зависит от него. В общем случае происходит преобразование из адресного кода в физический код – режим
адресации. В настоящее время известно более двух десятков различных способов адресации и их модификации. Остальные биты должны определять операнды
или их адреса, и поэтому они используются для комбинации режимов, адресов регистров, адресов памяти, относительных адресов и непосредственных
операндов. Обычно длина команды варьируется от 1 до 3 и даже 6 байт.</p>

<p>Рассмотрим формат команды МК AVR. Ячейка, из которой берётся операнд, называется источником. Ячейка, содержимое которой изменяется, называется
приёмником. В МК AVR каждая ячейка памяти программ является двухбайтной, поэтому большинство команд также состоят из двух байт (одного машинного
слова), и лишь некоторые являются 32-разрядными. При этом положение полей в командах переменное и зависит от команды. Многобайтная команда
размещается в последовательно расположенных ячейках памяти.</p>

<p>Рассмотрим, к примеру, команду <code>mov Rd, Rr</code>. Она копирует содержимое регистра Rr в регистр Rd. Регистр-источник Rr не изменяется. Её
код: 0010 11rd dddd rrrr. Здесь видно, что пять бит команды отводится под адрес приёмника (d) и пять бит – под адрес источника (r). Это позволяет
закодировать 2<sup>5</sup>=32 различные комбинации, поэтому для этой команды возможна работа с любым из 32 РОН как источника, так и приёмника.
Первые шесть бит являются кодом операции.</p>

<p>Рассмотрим другую команду: <code>lds Rd, K</code>. Она загружает один байт из памяти данных в РОН Rd. Адрес ячейки памяти, к которой
производится обращение, задаётся константой K. Код этой команды – 1001 000d dddd 0000 kkkk kkkk kkkk kkkk, где 0 ≤ d ≤ 31<sub>10</sub>; 0 ≤ k ≤
FFFF<sub>16</sub>. Здесь видно, что эта команда 32-разрядная, и выполняется за два такта. Первые два байта содержат КОП и адрес регистра-приёмника,
а остальные два байта – это адрес ячейки памяти.</p>

<p>Для доступа к памяти программ и данных (РОН, РВВ и ОЗУ) используются 11 режимов адресации: 8 для памяти данных и 3 для памяти программ. В МК AVR
реализованы <b>прямая</b> и <b>косвенная</b> адресация. При <b>прямой адресации</b> адреса операндов содержатся непосредственно в слове команды.</p>

<p>Прямая адресация одного регистра общего назначения. Этот способ используется в командах, оперирующих с одним из РОН. При этом адрес регистра
операнда (его номер) содержится в пяти разрядах слова команды (Рис. 42). Примером команд, использующих этот способ адресации, являются команды
работы со стеком (<code>push, pop</code>), команды инкремента (<code>inc</code>), декремента (<code>dec</code>), а также некоторые команды
арифметических операций.</p>

<div align="center"><img src="images/054.png" title="Прямая адресация одного регистра общего назначения"><br>
Рис. 42. Прямая адресация одного регистра общего назначения</div>

<p style="margin-top: 20px"><b>Прямая адресация двух регистров общего назначения</b> используется в командах, оперирующих одновременно с двумя РОН.
При этом адрес регистра источника содержится в разрядах 9, 3…0 (5 разрядов), а адрес регистра приёмника в разрядах 8…4 (5 разрядов) слова команды
(Рис. 43). Положение разрядов r и d на рисунке показано условно.</p>

<div align="center"><img src="images/055.png" title="Прямая адресация двух регистров общего назначения"><br>
Рис. 44. Прямая адресация двух регистров общего назначения</div>

<p style="margin-top: 20px">К командам, использующим этот способ адресации, относятся команда пересылки данных из регистра в регистр
(<code>mov</code>), а также большинство команд арифметических операций.</p>

<p>Здесь необходимо сделать одно замечание. Дело в том, что некоторые команды, имеющие только один регистр операнд, тем не менее используют
рассматриваемый способ адресации. Просто в этом случае источником и приёмником является один и тот же регистр. В качестве примера можно привести
команду очистки регистра (<code>clr Rd</code>), которая в действительности выполняет операцию “Исключающее ИЛИ” регистра с самим собой
(<code>eor Rd, Rd</code>).</p>

<p><b>Прямая адресация регистра ввода/вывода</b> используется командами пересылки данных между регистром ввода/вывода, расположенного в основном
пространстве ввода/вывода, и регистровым файлом – in и out. В этом случае адрес регистра ввода/вывода содержится в разрядах 10, 9, 3…0 (6 разрядов),
а адрес РОН – в разрядах 8…4 (5 разрядов) слова команды (Рис. 45). Положение разрядов r/d и P на рисунке показано условно.</p>

<div align="center"><img src="images/056.png" title="Прямая адресация регистра ввода/вывода"><br>
Рис. 45. Прямая адресация регистра ввода/вывода</div>

<p style="margin-top: 20px"><b>Прямая адресация ОЗУ</b> используется для обращения ко всему адресному пространству памяти данных. Имеется только две
команды, использующие этот способ адресации. Это команды пересылки байта между одним из РОН и ячейкой ОЗУ – <code>lds</code> и <code>sts</code>. В
памяти программ они занимают по два слова (32 разряда). В первом слове содержится код операции и адрес регистра общего назначения (в разрядах с 8-го
по 4-й). Во втором слове находится адрес ячейки памяти, к которой происходит обращение (Рис. 46).</p>

<div align="center"><img src="images/057.png" title="Прямая адресация ОЗУ"><br>
Рис. 46. Прямая адресация ОЗУ</div>

<p style="margin-top: 20px">При <b>косвенной адресации</b> адрес ячейки памяти находится в одном из индексных регистров X, Y и Z.</p>

<p><b>Простая косвенная адресация</b>. При использовании команд простой косвенной адресации обращение производится к ячейке памяти, адрес которой
находится в индексном регистре (Рис. 47). Никаких действий с содержимым индексного регистра при этом не производится.</p>

<div align="center"><img src="images/058.png" title="Простая косвенная адресация"><br>
Рис. 47. Простая косвенная адресация</div>

<p style="margin-top: 20px">Микроконтроллеры имеют 6 команд (по 2 для каждого индексного регистра) простой косвенной адресации:
<code>ld Rd, X/Y/Z</code> (пересылка байта из ОЗУ в РОН) и <code>st X/Y/Z, Rr</code> (пересылка байта из РОН в ОЗУ). Адрес регистра общего
назначения содержится в разрядах 4…8 слова команды.</p>

<p><b>Относительная косвенная адресация</b>. Адрес ячейки памяти, к которой производится обращение, получается суммированием содержимого индексного
регистра (Y или Z) и константой q, задаваемой в команде. Другими словами, позволяет адресовать 63 ячейки, начиная с адреса указанного в регистрах Y
или Z рис. 2.30. Положение разрядов R и q на рисунке показано условно.</p>

<div align="center"><img src="images/059.png" title="Относительная косвенная адресация"><br>
Рис. 48. Относительная косвенная адресация</div>

<p style="margin-top: 20px">МК ATmega имеют 4 команды относительной косвенной адресации (две для регистра Y и две для регистра Z): <code>ldd Rd,
Y+q/Z+q</code> (пересылка байта из ОЗУ в РОН) и <code>st Y+q/Z+q, Rr</code> (пересылка байта из РОН в ОЗУ). Адрес РОН содержится в разрядах 4…8
слова команды, а величина смещения – в разрядах 13, 11, 10, 2…0. Поскольку под значение смещения отводится только 6 разрядов, оно не может превышать
64.</p>

<p><b>Косвенная адресация с преддекрементом</b>. Содержимое индексного регистра сначала уменьшается на 1, а затем производится обращение по
полученному адресу (рис. 2.31).</p>

<div align="center"><img src="images/060.png" title="Косвенная адресация с преддекрементом"><br>
Рис. 49. Косвенная адресация с преддекрементом</div>

<p style="margin-top: 20px">Микроконтроллеры семейства поддерживают 6 команд (по 2 для каждого индексного регистра) косвенной адресации с
преддекрементом: <code>ld Rd, –X/–Y/–Z</code> (пересылка байта из ОЗУ в РОН) и <code>st –X/–Y/–Z, Rr</code> (пересылка байта из РОН в ОЗУ). Адрес
РОН содержится в разрядах 4…8 слова команды.</p>

<p><b>Косвенная адресация с постинкрементом</b>. После обращения по адресу, который находится в индексном регистре, содержимое индексного регистра
увеличивается на 1 (рис. 2.32).</p>

<div align="center"><img src="images/061.png" title="Косвенная адресация с постинкрементом"><br>
Рис. 50. Косвенная адресация с постинкрементом</div>

<p style="margin-top: 20px">Микроконтроллеры семейства поддерживают 6 команд (по 2 для каждого индексного регистра) косвенной адресации с
постинкрементом: <code>ld Rd, X+/Y+/Z+</code> (пересылка байта из ОЗУ в РОН) и <code> st X+/Y+/Z+, Rr</code> (пересылка байта из РОН в ОЗУ). Адрес
РОН содержится в разрядах 4…8 слова команды.</p>

<p><b>Адресация к памяти программ</b> позволяет получить доступ не только к программе, но и к различным константам, определённым в памяти программ
директривой <code>.db</code>. Чтобы такой блок данных не воспринимался МК как программный код, необходимо располагать его в конце программы. Для
пересылки байта из памяти программ имеется две специальных команды – <code>lpm</code> и <code>elpm</code> (последняя используется только в моделях
ATmega128, 256). При этом адрес, по которому производится чтение, определяется содержимым индексного регистра Z. Его старшие 15 разрядов определяют
адрес слова (0...32К), а младший разряд – какой из байтов будет прочитан: “0” – младший, “1” – старший байт. Команда <code>elpm</code> способна
адресовать всю память программ МК ATmega128x, 256x. При использовании этой команды адрес слова будет определяться разрядом RAMPZ0 регистра
ввода/вывода RAMPZ совместно со старшими 15 разрядами содержимого регистра Z.</p>

<div align="center"><img src="images/062.png" title="Адресация к памяти программ"><br>
Рис. 51. Адресация к памяти программ</div>
<br><br><br><br>




<a name="5"></a>
<table border=0 cellpadding=0 cellspacing=0 width=97% bgcolor=#ABB3D5>
  <tr><td bgcolor=#000000 colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
  <tr><td width="30"></td><td valign=center><span class=h>Система команд AVR</span></td></tr>
  <tr><td bgcolor=#000000 width="25" colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
</table>
<br>

<p>Вся система команд AVR делится на несколько групп по функциональному назначению:</p>

<ul>
 <li>Команды пересылки данных</li>
 <li>Арифметические</li>
 <li>Логические</li>
 <li>Команды операций с битами</li>
 <li>Команды передачи управления</li>
 <li>Команды управления системой</li>
</ul><br>




<a name="5.1"></a><p class="h3">5.1 Команды пересылок</p>

<p>Команды пересылки выполняют передачу данных из регистра в регистр и размещение данных в памяти. Они не формируют флаги и выполняются за один
такт.</p>

<center><table border=1 cellpadding="1" cellspacing="1">
 <tr align=center bgcolor="#D1D6E9">
  <td class="tcb">Мнемоника</td><td class="tcb">Описание</td><td class="tcb">Операции</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>mov Rd, Rr</code></pre></td> <td class="tc">Пересылка между РОН</td><td class="tc">Rd=Rr</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>movw Rd, Rr</code></pre></td> <td class="tc">Пересылка двухбайтовых значений</td><td class="tc">Rd+1:Rd=Rr+1:Rr</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>ldi Rd, K</code></pre></td> <td class="tc">Загрузка константы в РОН</td><td class="tc">Rd=K</td></tr>
 <tr bgcolor="#DCDCDC">
  <td class="tc"><pre style="margin: 0"><code>ld Rd, X
ld Rd, X+
ld Rd, -X
ld Rd, Y
ld Rd, Y+
ld Rd, -Y
ld Rd, Z
ld Rd, Z+
ld Rd, -Z</code></pre></td>
  <td class="tc">Косвенное чтение<br> Косв. чтение с постинкрементом<br> Косв. чтение с преддекрементом</td>
   <td class="tc">Rd=[X]<br> Rd=[X], X=X+1<br> X=X-1,Rd=[X]</td></tr>
 <tr bgcolor="#EAEAEA">
   <td class="tc"><pre style="margin: 0"><code>ldd Rd, Y+q
ldd Rd, Z+q</code></pre></td>
  <td class="tc">Косвенное относительное чтение</td> <td class="tc">Rd=[Y+q] Rd=[Z+q]</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>lds Rd, K</code></pre></td><td class="tc">Непосредственное чтение из ОЗУ</td> <td class="tc">Rd=[K]</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>mov Rd, Rr</code></pre></td><td class="tc">Пересылка между РОН</td> <td class="tc">Rd=Rr</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>movw Rd, Rr</code></pre></td><td class="tc">Пересылка двухбайтовых значений</td> <td class="tc">Rd+1:Rd=Rr+1:Rr</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>mov Rd, Rr</code></pre></td><td class="tc">Пересылка между РОН</td> <td class="tc">Rd=Rr</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>movw Rd, Rr</code></pre></td><td class="tc">Пересылка двухбайтовых значений</td> <td class="tc">Rd+1:Rd=Rr+1:Rr</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>mov Rd, Rr</code></pre></td><td class="tc">Пересылка между РОН</td> <td class="tc">Rd=Rr</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>movw Rd, Rr</code></pre></td><td class="tc">Пересылка двухбайтовых значений</td> <td class="tc">Rd+1:Rd=Rr+1:Rr</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>mov Rd, Rr</code></pre></td><td class="tc">Пересылка между РОН</td> <td class="tc">Rd=Rr</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>movw Rd, Rr</code></pre></td><td class="tc">Пересылка двухбайтовых значений</td> <td class="tc">Rd+1:Rd=Rr+1:Rr</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>mov Rd, Rr</code></pre></td>
  <td class="tc">Пересылка между РОН</td> <td class="tc">Rd=Rr</td></tr>
</table></center><br>

<p>Доступ к регистрам ввода/вывода осуществляется по их адресам, являющимися операндами команды. Вместе с тем при написании ассемблерных программ
гораздо удобнее обращаться к регистрам, используя вместо числовых значений адресов их стандартные, принятые в фирменной документации, символические
имена. Чтобы задать соответствие этих имён реальным адресам необходимо подключить в начале программы (при помощи директивы ассемблера
<code>.include</code>) файл определения адресов регистров ввода/вывода. Такое решение облегчит перенос программного обеспечения с одного типа МК на
другой.</p><br>




<a name="5.2"></a><p class="h3">5.2 Арифметические команды</p>

<p>Арифметические команды выполняются над содержимым двух регистров, указанных в команде. Результат помещается в регистр-приёмник. Сложение чисел с
разрядностью более одного байта производится программными методами. Например, сложение двух 16-разрядных чисел выполняется в два этапа – сначала
складываются младшие байты командой <code style="color: #005599">add</code>, а затем старшие командой <code style="color: #005599">adc</code> (с
учётом переноса). Рассмотрим операции вычитания. В силу внутренних особенностей АЛУ не обладает возможностями вычитания, оно осуществляет сложение,
представляя вычитаемое в форме дополнительного кода и затем складывая его. При арифметических операциях байт может интерпретироваться как:</p>

<ol>
 <li>двоичное число без знака в диапазоне от 0 до 255<sub>10</sub>, или 2<sup>8</sup>;</li>
 <li>число со знаком от –128<sub>10</sub> до +127<sub>10</sub>, в котором старший (седьмой) бит означает положительность или отрицательность
  числа;</li>
 <li>двоично-десятичное число без знака от 00 до 99;</li>
 <li>двоично-десятичное число со знаком от –50 до 49.</li>
</ol>

<div align="center" style="float: right; margin-left: 10px"><img src="images/gl3_img14.gif" title="Pис. 52. Диапазон положительных и отрицательных
чисел"><br>
Pис. 52. Диапазон положительных<br> и отрицательных чисел</div>

<p>Таким образом, весь диапазон чисел можно представить в виде круга, правую половину которого составляют положительные числа, а начиная с 80H по
FFH – отрицательные (рис. 52). С точки зрения машинных команд между знаковыми и беззнаковыми числами нет никакой разницы. Операнд представляет
собой 8-,16- или 32-разрядное число, все разряды которого абсолютно равноправны. Понятие знака введено исключительно для возможности манипулирования
(на логическом уровне) с отрицательными числами, но для процессора все числа одинаковы, а для программиста они отличаются тем, что для одних высший
разряд выступает в качестве информации о знаке числа (знаковые числа), а для других все разряды несут информации о самом числе (беззнаковые числа).
Выделение одного разряда под знак приводит к уменьшению возможной величины знакового числа вдвое. Так, максимальное значение беззнакового
8-разрядного числа равно <code>0b11111111</code>, или 255, максимальное же (минимальное) значение аналогичного знакового числа равно соответственно
<code>0b01111111</code>, или 127 (-128, или <code>0b10000000</code>). Если старший разряд знакового числа равен 1, число считается отрицательным,
если 0 – положительным. Чтобы определить величину знакового числа, следует произвести дополнение до двух, и приписать к полученному модулю (он
считается беззнаковым) знак (-), если старший бит искомого числа был равен 1. Легко видеть, что больше 127 (меньше -128) знаковое число быть не
может, поскольку для этих величин все информационные разряды уже установлены (сброшены), и дальнейшее увеличение (уменьшение) числа приведёт к
переносу в знаковый разряд (заёму из него) и, соответственно, изменению знака числа. При кодировании отрицательных чисел используется дополнительный
код, который может быть образован двумя способами:</p>

<ol>
 <li>ДК(а) = ā + 1, где ā , – это число, представленное в двоичном коде, в котором единицы инвертированы в нули и наоборот. Например, число
  05H=0000’0101. Тогда –05H = = 1111’1010 + 1 = 1111’1011 = FBH.</li>
 <li>ДК(а) = FF - a + 1. Число FFH в этой формуле – это максимальное шестнадцатеричное число, которое может быть представлено с помощью восьми
  бит.</li>
</ol>

<p>Такой способ представления удобен тем, что для выполнения операций сложения и вычитания как над числами со знаком, так и для чисел без знака
подходят одинаковые команды. Разница выявляется через анализ флагов в SREG.</p>

<p>Особенностью арифметико-логических группы команд в МК AVR является то, что в качестве операндов используются только РОН. Арифметико-логические
команды выполняют различные операции над знаковыми и беззнаковыми числами форматом 1 байт. Исключение составляют команды, в мнемонику которых входит
буква W – они оперируют с двухбайтными операндами, размещаемыми в смежных регистрах, например, r25:24.</p><br>

<center><table border=1 cellpadding="1" cellspacing="1">
 <tr align=center bgcolor="#D1D6E9">
  <td class="tcb">Мнемоника</td><td class="tcb">Описание</td><td class="tcb">Операции</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>add Rd, Rr</code></pre></td><td class="tc">Сложение двух РОН</td><td class="tc">Rd=Rr+Rd</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>adc Rd, Rr</code></pre></td><td class="tc">Сложение двух РОН с переносом</td><td class="tc">Rd= Rr+Rd+C</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>adiw Rd, K</code></pre></td><td class="tc">Сложение регистровой пары с константой</td><td class="tc">Rdh:Rdl=Rdh:Rdl+К</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code><b style="color: #005599">sub</b> Rd, Rr</code></pre></td><td class="tc">Вычитание двух РОН</td><td class="tc">Rd=Rr-Rd</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>subi Rd, K</code></pre></td><td class="tc">Вычитание константы из РОН</td><td class="tc">Rd=Rd-K</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>sbc Rd, Rr</code></pre></td><td class="tc">Вычитание двух РОН с заёмом</td><td class="tc">Rd=Rr-Rd-C</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>sbci Rd, K</code></pre></td><td class="tc">Вычитание константы из РОН с заёмом</td><td class="tc">Rd=Rr-K-C</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>sbiw Rd, K</code></pre></td><td class="tc">Вычитание константы из регистровой пары</td><td class="tc">Rdh:Rdl=Rdh:Rdl-К</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>inc Rd</code></pre></td><td class="tc">Инкремент РОН</td><td class="tc">Rd=Rd+1</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>dec Rd</code></pre></td><td class="tc">Декремент РОН</td><td class="tc">Rd=Rd-1</td></tr>
</table></center><br>

<p>Подгруппа арифметических команд выполняет сложение (<code style="color: #005599">add, adc, adiw</code>), вычитание
(<code style="color: #005599">sub, subi, sbc, sbci, sbiw</code>), инкремент и декремент.</p>

<p>Команда сложения <code style="color: #005599">add</code> Rd, Rr выполняет сложение содержимого регистра-источника Rr с регистром-примёником Rd,
сумма размещается в Rd. В мнемонической записи команды, как и в других двухоперандных командах первым указывается регистр-приёмник, затем –
регистр-источник.</p>

<p>Отдельную подгруппу арифметических команд составляют команды увеличения/уменьшения на единицу (инкремента/декремента):</p>

<ul>
 <li><code style="color: #005599">inc</code> – инкремент содержимого регистра;</li>
 <li><code style="color: #005599">dec</code> – декремент содержимого регистра.</li>
</ul>

<p>Особенность этих команд, в отличие от команд сложения/вычитания в том, что команды <code style="color: #005599">inc</code> и <code style="color:
#005599">dec</code> не формируют флаг C, поэтому они удобны для организации счётчика числа итераций цикла при выполнении вычислений с
многоразрядными числами.</p>

<p>Микроконтроллеры AVR Mega выполняют операции умножения (<code style="color: #005599">mul, muls, mulsu, fmul, fmuls, fmulsu</code>) целых и
дробных (F) чисел форматом один байт с учётом (S) и без учёта знака (U). Умножение знаковых и беззнаковых чисел требует разных команд, отдельную
группу составляют команды умножения дробных чисел.</p><br>

<center><table border=1 cellpadding="1" cellspacing="1">
 <tr align=center bgcolor="#D1D6E9">
  <td class="tcb">Мнемоника</td><td class="tcb">Описание</td><td class="tcb">Операции</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>mul Rd, Rr</code></pre></td><td class="tc">Умножение беззнаковых чисел</td><td class="tc">R1:R0=Rd×Rr</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>muls Rd, Rr</code></pre></td><td class="tc">Умножение чисел со знаком</td><td class="tc">R1:R0=Rd×Rr</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>mulsu Rd, Rr</code></pre></td><td class="tc">Умножение беззнакового числа на число со знаком</td><td class="tc">R1:R0=Rd×Rr</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>fmul Rd, Rr</code></pre></td><td class="tc">Умножение дробных беззнаковых чисел</td><td class="tc">R1:R0=(Rd×Rr)<<1</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>fmuls Rd, Rr</code></pre></td><td class="tc">Умножение дробных чисел со знаком</td><td class="tc">R1:R0=(Rd×Rr)<<1</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>fmulsu Rd, Rr</code></pre></td><td class="tc">Умножение дробного беззнакового числа и дробного числа со знаком</td><td class="tc">R1:R0=(Rd×Rr)<<1</td></tr>
</table></center><br>

<p>При операциях ввода/вывода может потребоваться работа в десятичной системе счисления. Отличие двоично-десятичного кода от шестнадцатеричного в
том, что каждая десятичная цифра кодируется одной тетрадой. Тогда 25<sub>10</sub> = 0010’0101<sub>2/10</sub> = 0001’100<sub>2</sub> = 19H.
Преобразование числа из шестнадцатеричной системы счисления в двоично-десятичную выполняется над каждой тетрадой числа следующим образом:</p>

<ol>
 <li>если значение младшей тетрады больше 9 или установился флаг H то к содержимому регистра прибавляется 6;</li>
 <li>если значение старшей тетрады больше 9 или установился флаг C, то к старшей тетраде прибавляется 6.</li>
</ol>

<p>Например:</p>

<table border=0>
 <tr><td valign="Middle" rowspan="2">ADD</td><td>38H</td></tr>
 <tr><td style='border-bottom:solid  #000000  1.0pt; padding-top: 4px'>54H</td></tr>
 <tr><td valign="Middle" rowspan="2">&nbsp;&nbsp;+</td><td>8CH</td></tr>
 <tr><td style='border-bottom:solid  #000000  1.0pt; padding-top: 4px'>&nbsp;&nbsp;6</td></tr>
 <tr><td>&nbsp;</td><td>92D</td></tr>
</table><br>




<a name="5.3"></a><p class="h3">5.3 Команды логических операций</p>

<p>Логические команды составляют еще одну группу команд МК AVR. Они сведены в таблицу и содержат команды И (логическое умножение), ИЛИ (логическое
сложение), Исключающее ИЛИ, НЕ (инверсия) и сдвига. Как и в рассмотренных ранее командах, режим адресации и здесь влияет на способ и место
нахождения других данных в микроконтроллерной системе.</p>

<p>Таблица истинности логических операций:</p><br>

<center><table border="1" cellpadding="1" cellspacing="1">
 <tr bgcolor="#D1D6E9">
     <td valign="Middle" colspan="2" width="100"><p class=tcb>Вход</p></td>
     <td valign="Middle" width="50"><p class=tcb>И</p></td>
     <td valign="Middle" width="50"><p class=tcb>ИЛИ</p></td>
     <td valign="Middle"><p class=tcb>Исключающее<br>ИЛИ</p></td>
 </tr>
 <tr bgcolor=#DCDCDC>
  <td><p class=tc>0</p></td><td><p class=tc>0</p></td><td><p class=tc>0</p></td><td><p class=tc>0</p></td><td><p class=tc>0</p></td></tr>
 <tr bgcolor=#EAEAEA>
  <td><p class=tc>0</p></td><td><p class=tc>1</p></td><td><p class=tc>0</p></td><td><p class=tc>1</p></td><td><p class=tc>1</p></td></tr>
 <tr bgcolor=#DCDCDC>
  <td><p class=tc>1</p></td><td><p class=tc>0</p></td><td><p class=tc>0</p></td><td><p class=tc>1</p></td><td><p class=tc>1</p></td></tr>
 <tr bgcolor=#EAEAEA>
  <td><p class=tc>1</p></td><td><p class=tc>1</p></td><td><p class=tc>1</p></td><td><p class=tc>1</p></td><td><p class=tc>0</p></td></tr>
</table></center><br>

<center><table border=1 cellpadding="1" cellspacing="1">
 <tr align=center bgcolor="#D1D6E9">
  <td class="tcb">Мнемоника</td><td class="tcb">Описание</td><td class="tcb">Операции</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>and Rd, Rr</code></pre></td><td class="tc">«Логическое И» двух РОН</td><td class="tc">Rd=Rd•Rr</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>andi Rd, K</code></pre></td><td class="tc">«Логическое И» РОН и константы</td><td class="tc">Rd=Rd•K</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>eor Rd, Rr</code></pre></td><td class="tc">«Исключающее ИЛИ» двух РОН</td><td class="tc">Rd=Rd&oplus;Rr</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>or Rd, Rr</code></pre></td><td class="tc">«Логическое ИЛИ» двух РОН</td><td class="tc">Rd=Rd∨Rr</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>ori Rd, K</code></pre></td><td class="tc">«Логическое ИЛИ» РОН и константы</td><td class="tc">Rd=Rd∨K</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>com Rd</code></pre></td><td class="tc">Перевод в обратный код</td><td class="tc">Rd=$FF-Rd</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>neg Rd</code></pre></td><td class="tc">Перевод в дополнительный код</td><td class="tc">Rd=$00-Rd</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>clr Rd</code></pre></td><td class="tc">Сброс всех разрядов РОН</td><td class="tc">Rd=$00</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>ser Rd</code></pre></td><td class="tc">Установка всех разрядов РОН</td><td class="tc">Rd=$FF</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>tst Rd</code></pre></td><td class="tc">Проверка РОН на отрицательное или нулевое значение</td><td class="tc">Rd•Rd</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>swap Rd</code></pre></td><td class="tc">Обмен местами тетрад РОН</td><td class="tc">Rd(3..0)=Rd(7...4),<br>Rd(7..4)=Rd(3..0)</td></tr>
</table></center><br>

<p>Логические команды позволяют установить в единицу, сбросить в ноль, инвертировать и проверить заданные биты. Установка бита в единицу
производится формированием маски, которая определяет позицию требуемого бита. Маска для установки бита – это байт с нулями во всех битах, кроме
искомого. Затем выполняется операция ИЛИ с содержимым регистра и полученной маской. Аналогично, сброс бита в ноль осуществляется операцией И над
маской, с единицами во всех битах, кроме требуемого, обозначенного нулём. После этих операций следуют команды сравнения и перехода по условию
состояния флага Z.</p>

<p>Для примера рассмотрим методы изменения содержимого пятого бита регистра r0:</p><br>

<center><table border="1" cellpadding="1" cellspacing="1">
 <tr bgcolor="#D1D6E9">
  <td valign="Middle"><p class=tcb>Установка в 1</p></td><td valign="Middle"><p class=tcb>Сброс в 0</p></td><td valign="Middle"><p class=tcb>Инверсия бита</p></td></tr>
 <tr bgcolor=#DCDCDC>
  <td><pre style="margin: 0"><code>ldi R16, 0b00100000
ori R0,  0b00100000</code></pre></td>
  <td><pre style="margin: 0"><code>andi R0, 0b11011111</code></pre></td>
  <td><pre style="margin: 0"><code>eor R0, R16</code></pre></td></tr>
</table></center><br>

<p>Другой пример – проанализируем содержимое пятого бита регистра R0:</p><br>

<center><table border="1" cellpadding="1" cellspacing="1">
 <tr bgcolor="#D1D6E9" height="50">
  <td valign="Middle"><pre style="margin: 0;"><code>andi R0, 0b00100000</code></pre></td>
  <td><pre style="font-family: sans-serif; font-size: 14px; margin: 0"> b<sub>7</sub>   b<sub>6</sub>   b<sub>5</sub>   b<sub>4</sub>    b<sub>3</sub>   b<sub>2</sub>   b<sub>1</sub>   b<sub>0</sub>
<ins> 0     0     1    0     0     0     0    0</ins>
 0     0     b<sub>5</sub>   0     0     0     0    0</pre></td></tr>
  <tr bgcolor="#D1D6E9"><td colspan="2" valign="Middle">
    <pre style="margin: 0"><code>breq M0 ;условный переход на метку М0, если флаг Z = 1</code></pre></td></tr></table></center><br>

<p>При выполнении логических команд формируются флаги S, N и Z. Флаг V обнуляется. Это даёт возможность определить некоторые свойства операнда в
регистре, не изменяя его самого, – знак числа, и равно ли оно нулю (команды <code style="color: #005599">andi, ori</code>). Команда
<code style="color: #005599">eor</code> R0,R0 производит обнуление регистра. Команда <code style="color: #005599">ori</code> также позволяет
упаковать нескольких полей в одно слово. Например, результатом операции с операндами XXXX0000 и 0000YYYY будет упакованное слово XXXXYYYY.</p>

<p>Команда <code style="color: #005599">tst</code> Rs позволяет проверить содержимое регистра на ноль или минус и установить флаги N и Z. Для этого
МК выполняет команду <code style="color: #005599">and</code> Rs, Rs.</p><br>




<a name="5.4"></a><p class="h3">5.4 Команды операций с битами</p>

<p>МК AVR имеют ряд команд, позволяющих эффективно работать с отдельными битами.</p><br>

<center><table border=1 cellpadding="1" cellspacing="1">
 <tr align=center bgcolor="#D1D6E9">
  <td class="tcb">Мнемоника</td><td class="tcb">Описание</td><td class="tcb">Операции</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>cbr Rd, K</code></pre></td><td class="tc">Сброс разряда(ов) РОН</td><td class="tc">Rd=Rd•($FF-K)</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>sbr Rd, K</code></pre></td><td class="tc">Установка разряда(ов) РОН</td><td class="tc">Rd=RdvK</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>cbi A, b</code></pre></td><td class="tc">Сброс разряда РВВ</td><td class="tc">A, b=0</td></tr>
 <tr bgcolor=#EAEAEA>
  <td class="tc"><pre style="margin: 0"><code>sbi A, b</code></pre></td><td class="tc">Установка разряда РВВ</td><td class="tc">A, b=1</td></tr>
 <tr bgcolor="#DCDCDC">
  <td class="tc"><pre style="margin: 0"><code><b style="color: #005599">bclr</b> s</code></pre></td><td class="tc">Cброс флага</td><td class="tc">SREG.s=0</td></tr>
 <tr bgcolor=#EAEAEA>
  <td class="tc"><pre style="margin: 0"><code><b style="color: #005599">bset</b> s</code></pre></td><td class="tc">Установка флага</td><td class="tc">SREG.s=1</td></tr>
 <tr bgcolor="#DCDCDC">
  <td class="tc"><pre style="margin: 0"><code>bld Rd, b</code></pre></td><td class="tc">Загрузка разряда РОН из флага T (SREG)</td><td class="tc">Rd.b=T</td></tr>
 <tr bgcolor=#EAEAEA>
  <td class="tc"><pre style="margin: 0"><code>bst Rr, b</code></pre></td><td class="tc">Запись разряда РОН во флаг T (SREG)</td><td class="tc">T=Rr.b</td></tr>
 <tr bgcolor="#DCDCDC">
  <td class="tc"><pre style="margin: 0"><code><b style="color: #005599">cl* </b></code></pre></td><td class="tc">Сброс флага *</td><td class="tc">*=0</td></tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code><b style="color: #005599">se* </b></code></pre></td><td class="tc">Установка флага *</td><td class="tc">*=1</td></tr>
</table></center><br>

<p>Команды <code style="color: #005599">se*</code> и <code style="color: #005599">cl*</code> позволяют устанавливать и сбрасывать отдельные флаги
регистра статуса SREG. Вместо звёздочки подставляется нужный флаг, например, <code style="color: #005599">cli</code> – запрет прерываний.</p><br>




<a name="5.5"></a><p class="h3">5.5 Команды сдвига</p>

<p>Би́товый сдвиг – изменение позиций битов в слове на одну и ту же величину. Команды сдвига похожи друг на друга поведением средних битов, которые
просто сдвигаются влево или вправо, однако, поведение крайних битов, которые уходят или появляются в байте, зависит от типа сдвига. МК AVR имеет
пять команд сдвига.</p><br>

<center><table border=1 cellpadding="1" cellspacing="1">
 <tr align=center bgcolor="#D1D6E9"><td class="tcb">Мнемоника</td><td class="tcb">Описание</td><td class="tcb">Операции</td></tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>asr Rd</code></pre></td>
  <td class="tc">Арифметический сдвиг вправо</td>
  <td class="tc">Rd(n) = Rd(n + 1), n=0..6</td>
 </tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>lsl Rd</code></pre></td>
  <td class="tc">Логический сдвиг влево</td>
  <td class="tc">Rd(n+1)=Rd(n), Rd(0) = 0</td>
 </tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>lsr Rd</code></pre></td>
  <td class="tc">Логический сдвиг вправо</td>
  <td class="tc">Rd(n)=Rd(n+1), Rd(7) = 0</td>
 </tr>
 <tr bgcolor="#EAEAEA">
  <td class="tc"><pre style="margin: 0"><code>rol Rd</code></pre></td>
  <td class="tc">Циклический сдвиг влево</td>
  <td class="tc">Rd(0)=C,<br>Rd(N+1)=Rd(n), C=Rd(7)</td>
 </tr>
 <tr bgcolor=#DCDCDC>
  <td class="tc"><pre style="margin: 0"><code>ror Rd</code></pre></td>
  <td class="tc">Циклический сдвиг вправо</td>
  <td class="tc">Rd(7)=C,<br>Rd(n)=Rd(n+1), C=Rd(0)</td>
 </tr>
</table></center><br>

<div align="center"><img src="images/063.gif"><br>
Рис. 53. Выполнение команд циклического сдвига</div>

<p style="margin-top: 20px">При <i>логическом сдвиге</i> (<code style="color: #005599">lsl</code>, <code style="color: #005599">lsr</code>) уходящий
бит исчезает, а на месте появившегося бита записывается бит 0. Например, при логическом сдвиге 10101010b влево на 1 бит получим число 01010100b, что
эквивалентно выполнению команды <code style="color: #005599">add</code> <code>Rd</code>, <code>Rd</code>. Если сделать сдвиг исходного числа вправо
на 1 бит, то получим число 01010101b. Уходящий бит сохраняется во флаге переноса.</p>

<div align="center" style="float: right; margin-left: 10px"><img src="images/063.1.png" title="Pис. 54. Арифметический сдвиг вправо"><br>
Pис. 54. Арифметический сдвиг<br> вправо <code style="color: #005599">asr</code></div>

<p>При <i>арифметическом сдвиге</i> (<code style="color: #005599">asr</code>) рис.53, содержимое регистра рассматривается не просто как группа
битов, а как целое число в дополнительном коде. Особенность арифметического сдвига состоит в неизменности старшего (знакового) разряда. При сдвиге
вправо уходящий бит исчезает, не влияя на оставшиеся биты, а на месте появившегося бита устанавливается бит, соответствующий знаку. Например, сдвиг
влево числа 11111010b = −06 даст число 11110100b = −12. Если сделать сдвиг исходного числа вправо, то получим число 11111101b = −3. Легко заметить,
что при арифметическом сдвиге сдвиг влево соответствует умножению на 2, а сдвиг вправо – делению на 2 с округлением к −∞. Например:</p>

<p style="clear: both;"><pre style="width: 230px">
    1011 = −5     1111 = −1
      >>a 1         >>a 1
    ----–––––     ----–––––
    1101 = −3     1111 = −1</pre></p>

<p>Умножение на 2 двухбайтового числа:<br>
<code style="color: #005599">lsl</code> <code>R1</code><br><code style="color: #005599">rol</code> <code>R2</code></p>

<p>Деление на 2 двухбайтового числа:<br>
<code style="color: #005599">asr</code> <code>R2</code><br><code style="color: #005599">rol</code> <code>R1</code></p>

<p>При арифметическом сдвиге вправо положительных чисел предельное значение составляет 0; при сдвиге влево отрицательных чисел предельное значение
составляет FFH = –1.</p><br>



<a name="5.6"></a><p class="h3">5.6 Команды сравнения</p>

<p>Команды сравнения используются для формирования флагов перед условным переходом. При этом выполняется вычитание без сохранения в
регистре.</p>

<center><table border=1 cellpadding="1" cellspacing="1">
 <tr align=center bgcolor="#D1D6E9"><td class="tcb">Мнемоника</td><td class="tcb">Описание</td><td class="tcb">Операции</td></tr>
 <tr bgcolor=#DCDCDC><td class="tc"><pre style="margin: 0"><code>cp Rd, Rr</code></pre></td>
  <td class="tc">Сравнение РОН</td>
  <td class="tc">RD-Rr</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>cpc Rd, Rr</code></pre></td>
  <td class="tc">Сравнение РОН с учётом переноса</td>
  <td class="tc">Rd-Rr-C</td>
 </tr>
 <tr bgcolor=#DCDCDC><td class="tc"><pre style="margin: 0"><code>cpi Rd, K</code></pre></td>
  <td class="tc">Сравнение РОН с константой</td>
  <td class="tc">Rd-K</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>cpse Rd, Rr</code></pre></td>
  <td class="tc">Сравнение и пропуск следующей команды при равенстве</td>
  <td class="tc">Если Rd=Rr,<br>то PC=PC+2(3)</td>
 </tr>
</table></center><br><br>




<a name="5.7"></a><p class="h3">5.7 Команды передачи управления</p>

<p>Эта группа содержит команды перехода по какому-либо условию, изменяя последовательный ход программы. Имеются команды двух типов: условного и
безусловного переходов. Безусловный переход просто выполняют операцию, определенную счётчиком команд; условные – проверяют состояние одного из
флагов процессора для определения необходимости в ветвлении.</p>

<center><table border=1 cellpadding="1" cellspacing="1">
 <tr align=center bgcolor="#D1D6E9"><td class="tcb">Мнемоника</td><td class="tcb">Описание</td><td class="tcb">Операции</td></tr>
 <tr bgcolor=#DCDCDC><td class="tc"><pre style="margin: 0"><code>rjmp k</code></pre></td>
  <td class="tc">Относительный безусловный переход</td>
  <td class="tc">PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>ijmp</code></pre></td>
  <td class="tc">Косвенный безусловный переход</td>
  <td class="tc">PC=Z</td>
 </tr>
 <tr bgcolor=#DCDCDC><td class="tc"><pre style="margin: 0"><code>jmp k</code></pre></td>
  <td class="tc">Абсолютный переход</td>
  <td class="tc">PC=k</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>sbrc Rr, b</code></pre></td>
  <td class="tc">Пропуск след. команды, если разряд РОН сброшен</td>
  <td class="tc">Если Rr.b=0,<br>то PC=PC+2(3)</td>
 </tr>
 <tr bgcolor="#DCDCDC"><td class="tc"><pre style="margin: 0"><code>sbrs Rr, b</code></pre></td>
  <td class="tc">Пропуск след. команды, если разряд РОН установлен</td>
  <td class="tc">Если Rr.b=1,<br>то PC=PC+2(3)</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>sbic A, b</code></pre></td>
  <td class="tc">Пропуск след. команды, если разряд PBB сброшен</td>
  <td class="tc">Если A.b=0,<br>то PC=PC+2(3)</td>
 </tr>
 <tr bgcolor="#DCDCDC"><td class="tc"><pre style="margin: 0"><code>sbis A, b</code></pre></td>
  <td class="tc">Пропуск след. команды, если разряд PBB установлен</td>
  <td class="tc">Если A.b=1,<br>то PC=PC+2(3)</td>
 </tr>
</table></center><br>

<p>Команды проверки-пропуска работают по принципу: "Проверка условия; если справедливо – пропуск следующей команды."</p>

<p>В AVR имеется группа команд условных переходов (<em>BRanch</em>), проверяющих флаги в SREG. Они реализуют конструкции, аналогичные
<code>if-then</code> или <code>switch-case</code> языка C. Для этих команд передача управления возможна на 64 слова назад или на 63 слова вперёд
относительно текущего счётчика команд.</p>

<p>Команды <code style="color: #005599">brbc</code> и <code style="color: #005599">brbs</code> могут быть подставлены вместо любой пары команд
переходов, однако их читаемость хуже.</p><br>

<center><table border=1 cellpadding="1" cellspacing="1">
 <tr align=center bgcolor="#D1D6E9"><td class="tcb">Мнемоника</td><td class="tcb">Описание</td><td class="tcb">Операции</td></tr>
 <tr bgcolor=#DCDCDC><td class="tc"><pre style="margin: 0"><code><b style="color: #005599">brbc</b> s, k</code></pre></td>
  <td class="tc">Переход, если флаг S регистра SREG сброшен</td>
  <td class="tc">Если SREG.s=0,<br>то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code><b style="color: #005599">brbs</b> s, k</code></pre></td>
  <td class="tc">Переход, если флаг S регистра SREG установлен</td>
  <td class="tc">Если SREG.s=1,<br>то PC=PC+k+1</td>
 </tr>
 <tr bgcolor=#DCDCDC><td class="tc"><pre style="margin: 0"><code>brcs k,<br>brlo k</code></pre></td>
  <td class="tc">Переход по переносу<br>Переход по “меньше”</td>
  <td class="tc">Если С=1, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>brcc k<br>brsh k</code></pre></td>
  <td class="tc">Переход, если нет переноса <br>“больше или равно”</td>
  <td class="tc">Если С=0, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#DCDCDC"><td class="tc"><pre style="margin: 0"><code>breq k</code></pre></td>
  <td class="tc">Переход по “равно”</td>
  <td class="tc">Если Z=1, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>brne k</code></pre></td>
  <td class="tc">Переход по “не равно”</td>
  <td class="tc">Если Z=0, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#DCDCDC"><td class="tc"><pre style="margin: 0"><code>brmi k</code></pre></td>
  <td class="tc">Переход по “отрицательное значение”</td>
  <td class="tc">Если N=1, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>brpl k</code></pre></td>
  <td class="tc">Переход по “положительному значению”</td>
  <td class="tc">Если N=0, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#DCDCDC"><td class="tc"><pre style="margin: 0"><code>brge k</code></pre></td>
  <td class="tc">Переход по “больше или равно” (числа со знаком)</td>
  <td class="tc">Если (N&oplus;V)=0, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>brlt k</code></pre></td>
  <td class="tc">Переход по “меньше нуля” числа со знаком)</td>
  <td class="tc">Если (N&oplus;V)=1, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#DCDCDC"><td class="tc"><pre style="margin: 0"><code>brhs k</code></pre></td>
  <td class="tc">Переход по полупереносу</td>
  <td class="tc">Если H=1, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>brhc k</code></pre></td>
  <td class="tc">Переход, если нет полупереноса</td>
  <td class="tc">Если H=0, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#DCDCDC"><td class="tc"><pre style="margin: 0"><code>brts k</code></pre></td>
  <td class="tc">Переход, если флаг Т установлен</td>
  <td class="tc">Если T=1, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>brtc k</code></pre></td>
  <td class="tc">Переход, если флаг Т сброшен</td>
  <td class="tc">Если Т=0, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#DCDCDC"><td class="tc"><pre style="margin: 0"><code>brvs k</code></pre></td>
  <td class="tc">Переход по переполнению доп. кода</td>
  <td class="tc">Если V=1, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>brvc k</code></pre></td>
  <td class="tc">Переход, если нет переполнения доп. кода</td>
  <td class="tc">Если V=0, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#DCDCDC"><td class="tc"><pre style="margin: 0"><code>brid k</code></pre></td>
  <td class="tc">Переход, если прерывания запрещены</td>
  <td class="tc">Если I=0, то PC=PC+k+1</td>
 </tr>
 <tr bgcolor="#EAEAEA"><td class="tc"><pre style="margin: 0"><code>brie k</code></pre></td>
  <td class="tc">Переход, если прерывания разрешены</td>
  <td class="tc">Если I=1, то PC=PC+k+1</td>
 </tr>
</table></center><br>

<p>Команды проверки наряду с командами сравнения позволяют реализовать типовые конструкции языков высокого уровня: проверки на равно/не равно,
больше/меньше, и другие. Например, если в R16 и R17 содержатся беззнаковые операнды, то их можно сравнить следующим образом:</p>

<table width="100%" cellspacing="0" cellpadding="4" border="0">
 <tr><td width="400"><pre><Code>;проверка на равно/не равно
      cp r16,r17
      breq yes	;переход, если r16 = r17
no:   ldi r18,0	;r16 /= r17 (не равны)
      rjmp end
yes:  ldi r18,1	;r16 == r17 (равны)
end:  rjmp end

;проверка на меньше/больше-либо равно
      cp r16,r17
      brlo yes	;переход, если r16 < r17
no:   ldi r18,0	;r16 >= r17
      rjmp end
yes:  breq no	;r16 < r17
      ldi r18,1
end:  rjmp end

;проверка на больше/меньше-либо равно
      cp r16,r17
      brsh yes	;переход, если r16 > r17
no:   ldi r18,0	;r16 <= r17
      rjmp end
yes:  breq no
      ldi r18,1	;r16 > r17
end:  rjmp end
</Code></pre>
</td>
<td></td>
</tr></table><br>




<a name="5.8"></a><p class="h3">5.8 Команды работы с подпрограммами</p>
<p>
    Как и команды передачи управления, эта группа команд позволяет осуществить безусловный переход либо вызов подпрограммы по условию. Иногда их называют командами переходов с возвратом.
</p>
<p>
    По команде <code style="color: #005599">call</code> текущее значение счётчика команд записываются в стек, а в счётчик команд загружается новый адрес. <code style="color: #005599">ret</code> – возврат из подпрограммы, при которм содержимое вершины стека переписывается в счётчик команд.
</p>
<br>
<center>
    <table border=1 cellpadding="1" cellspacing="1">
        <tr align=center bgcolor="#D1D6E9">
            <td class="tcb">Мнемоника</td>
            <td class="tcb">Описание</td>
            <td class="tcb">Операции</td>
        </tr>
        <tr bgcolor=#DCDCDC>
            <td class="tc">
                <pre style="margin: 0"><code>rcall k</code></pre>
            </td>
            <td class="tc">Относительный вызов подпрограммы</td>
            <td class="tc">PC=PC+k+1</td>
        </tr>
        <tr bgcolor="#EAEAEA">
            <td class="tc">
                <pre style="margin: 0"><code>icall</code></pre>
            </td>
            <td class="tc">Косвенный вызов подпрограммы</td>
            <td class="tc">PC=Z</td>
        </tr>
        <tr bgcolor=#DCDCDC>
            <td class="tc">
                <pre style="margin: 0"><code>call k</code></pre>
            </td>
            <td class="tc">Абсолютный вызов подпрограммы</td>
            <td class="tc">PC=k</td>
        </tr>
        <tr bgcolor="#EAEAEA">
            <td class="tc">
                <pre style="margin: 0"><code>ret</code></pre>
            </td>
            <td class="tc">Возврат из подпрограммы</td>
            <td class="tc">PC=STACK</td>
        </tr>
        <tr bgcolor="#DCDCDC">
            <td class="tc">
                <pre style="margin: 0"><code>reti</code></pre>
            </td>
            <td class="tc">Возврат из подпрограммы обработки прерывания</td>
            <td class="tc">PC=STACK</td>
        </tr>
    </table>
</center>
<br>
<p>
    Стеком называют безадресный способ организации памяти, доступ к которой организован по принципу “последним пришёл, первым ушел” (Last Input First Output – LIFO). Стековая память позволяет cохранять адреса возврата и флаги при обработке прерываний и вызове подпрограмм, а также передавать параметры в подпрограммы.
</p>
<p>
    Принцип работы стековой памяти состоит в следующем. При старте программы инициализируется регистр-указатель стека SP (Stack Pointer):
</p>
<pre style="width:400px;"><code>RESET:ldi R16,Low(RAMEND) ; Инициализация стека
      out SPL,R16
      ldi R16,High(RAMEND)
      out SPH,R16</code></pre>
                                        <p>
                                            Обычно он ссылается на самую последнюю ячейку оперативной памяти данных и указывает на вершину стека. Адрес последней ячейки ОЗУ называется RAMEND, и в качестве зарезервированной константы прописан в файле определений конкретной модели МК. Например, для ATmega328p он равен 08FFH; для ATmega2560 - 21FFH. Так как адреса ОЗУ являются 16-битными, то для формирования значения SP через восьмиразрядные РОН приходится записывать отдельно младшую (SPL) и старшую (SPH) части. Кроме того, для хранения адресов возврата в стеке требуется по 2 ячейки памяти, поэтому при обращении к стеку регистр SP изменяется на 2.
                                        </p>
                                        <p>
                                            Когда происходит вызов подпрограммы, МК автоматически сохраняет адрес возврата А в стеке и уменьшает на 2 значение регистра SP (рис. Х). При этом указатель смещается на следующую свободную ячейку стека. Если в подпрограмме происходит вызов другой подпрограммы, то адрес её возврата B записывается в эту свободную ячейку, а указатель стека снова смещается на 2. При выходе из подпрограммы считывание данных из стека происходит в обратном порядке, начиная с кода B, который был записан последним. Заметим, что выборка, например кода А, невозможна до выборки кода В, что определяется механизмом обращения при записи и чтении типа LIFO. Кроме того, для фиксации переполнения стека желательно формировать специальный признак переполнения.
                                        </p>
                                        <div align="center">
                                            <br>
                                            <img src="images/064.png"
                                                 title="Рис.12. Стек LIFO"><br>
                                            <br>
                                            Рис.12. Стек LIFO
                                        </div>
                                        <p>
                                            В различных МП используются и другие алгоритмы записи/чтения. Так, стек может расти вниз, а не вверх, и его указатель может изменяться как до записи, так и после. Начальное значение указателя стека определяется программистом или операционной системой, а в некоторых МК, например MCS51, устанавливается при сбросе.
                                        </p>
                                        <p>
                                            В сложных МП при вызове подпрограмм и прерываниях флаги сохраняются в стеке аппаратно. Если указатель попал в область, отведенную для векторов прерываний, команд или данных, то произойдет автоматическое переполнение стека. В простых МП за сохранением регистра флагов должен следить сам программист.
                                        </p>

                                        <a name="5.9"></a>
                                        <p class="h3" style="margin: 20px 0;">5.9 Команды управления системой</p>
                                        <br>
                                        <center>
                                            <table border=1 cellpadding="1" cellspacing="1">
                                                <tr align=center bgcolor="#D1D6E9">
                                                    <td class="tcb">Мнемоника</td>
                                                    <td class="tcb">Описание</td>
                                                </tr>
                                                <tr bgcolor=#DCDCDC>
                                                    <td class="tc">
                                                        <pre style="margin: 0"><code>nop</code></pre>
                                                    </td>
                                                    <td class="tc">Нет операции</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">
                                                        <pre style="margin: 0"><code><b style="color: #005599">sleep</b></code></pre>
                                                    </td>
                                                    <td class="tc">Переход в «спящий» режим</td>
                                                </tr>
                                                <tr bgcolor=#DCDCDC>
                                                    <td class="tc">
                                                        <pre style="margin: 0"><code>wdr</code></pre>
                                                    </td>
                                                    <td class="tc">Сброс сторожевого таймера</td>
                                                </tr>
                                            </table>
                                        </center>
                                        <br>
                                        <br><br>



										
<a name="7"></a>
<table border=0 cellpadding=0 cellspacing=0 width=97% bgcolor=#ABB3D5>
  <tr><td bgcolor=#000000 colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
  <tr><td width="30"></td><td valign=center><span class=h>Организация ввода/вывода в микропроцессорной системе</span></td></tr>
  <tr><td bgcolor=#000000 width="25" colspan="2"><img src=../Оболочка/images/raspor.gif height="1"></td></tr>
</table>
<br>

<p>Процесс обмена данными между процессором, памятью и внешними устройствами (ВУ), называется вводом-выводом информации. Физически обмен данными с
ВУ производится посредством интерфейсов, – унифицированных аппаратных, программных и конструктивных средств, необходимых для реализации алгоритмов
взаимодействия различных функциональных устройств. Т.е. совокупность средств, методов и правил взаимодействия между элементами системы.</p>

<p>К основным характеристикам интерфейса относят: функциональное назначение, тип организации связей, принцип обмена информацией, способ обмена,
режим обмена, количество линий, число линий для передачи данных (разрядность), количество адресов, количество команд, быстродействие, длину линий
связи, число подключаемых устройств (нагрузочная способность), тип линии связи.</p>

<p>По функциональному назначению интерфейсы разделяют на магистральные (внутримашинные), внешние интерфейсы периферийных устройств, системные
(интерфейсы локальных сетей).</p>

<p>По типу организации связей интерфейсы подразделяют на магистральные, радиальные, древовидные, радиально-магистральные.</p>

<p>По принципу обмена информацией – с параллельной, последовательной и параллельно-последовательной передачей информации.</p>

<p>По режиму обмена информацией – с симплексным (только один из абонентов может в любой момент времени инициировать передачу информации),
полудуплексным (любой абонент может начать передачу информации другому, если линия связи интерфейса свободна), дуплексным (когда каждый абонент
может начать передачу информации другому в любой момент времени) и мультиплексным(когда в каждый момент времени связь может быть осуществлена между
парой абонентов в любом, но единственном направлении от одного к другому) режимами обмена.</p>

<p>По способу передачи информации во времени различают интерфейсы с синхронной передачей данных (с постоянной временной привязкой в цикле сбора
информации) и с асинхронной (без постоянной временной привязки к определенному временному интервалу цикла сбора). В первом случае передача
синхронизируется специальными синхроимпульсами в виде последовательности прямоугольных импульсов. Во втором – управляющими сигналами ГОТОВНОСТЬ к
обмену, НАЧАЛО, КОНЕЦ, КОНТРОЛЬ обмена.</p>

<p>Параллельная передача данных между интерфейсом и ВУ является наиболее простым способом обмена. При этом все биты данных передаются одновременно,
каждый – по своей сигнальной линии, за один такт. Для обратной связи используются две сигнальные линии: “Данные готовы” и “Данные приняты”.
Очевидно, что такой способ обеспечивает высокую скорость обмена, но требует большого числа линий связи. Кроме того, между сигнальными линиями ними
возникает интерференционное взаимодействие, приводящее к искажению передаваемых сообщений. Поэтому параллельный интерфейс нерационален для
подключения удалённых устройств.</p>

<p>Параллельная передача использовалась, например, в интерфейсе IDE жёсткого диска и в LPT для связи с принтером. В настоящее время линии
параллельных интерфейсов используются в качестве дискретных входов/выходов для управления устройствами, имеющими два состояния:
включено/выключено.</p>

<p>При последовательном обмене отправка данных происходит по одному биту за раз, что сокращает общее количество сигнальных линий, но усложняет
контроллер ввода-вывода. Контроллер передатчика получает машинное слово за раз и должен передавать по одному биту, а контроллер приёмника в свою
очередь должен получать биты и сохранять в том же порядке. Малое количество сигнальных линий позволяет увеличивать скорость передачи сообщения.</p>
<br><br>




<a name="7.1"></a>
<p class="h3">7.1 Дискретные порты ввода/вывода (интерфейс)</p>

<p>
Порты ввода-вывода – это компоненты ЭВМ, предоставляющие возможность
её взаимодействия с внешним миром. Через порты ввода процессор получает
внешние воздействия в виде управляющих сигналов от кнопок или датчиков.
Через порты вывода процессор управляет внешними устройствами
(реле, двигателями, световыми индикаторами, дисплеями, и т.д.).
Физически порт представляет собой логическое объединение сигнальных линий,
через которое принимаются и передаются данные. На каждую линию порта МК в режиме вывода можно программно подать
напряжение или отключить, а в режиме ввода определить, есть ли на ней сигнал, поданный извне или нет.
Процессор работает с портами ввода-вывода так же, как и с ячейками памяти – он читает число из порта
ввода или записывает число в порт вывода.
</p>

<p>
С программной точки зрения в качестве порта вывода чаще всего выступает обыкновенный параллельный регистр,
а порт ввода – это ключевая схема, которая по команде центрального процессора подаёт внешние данные на его входы.
</p>

<div align="center">
    <table>
        <tr>
            <td><img src="images/109.png" style="margin: 0px 20px;" : 30px;"></td>
            <td><img src="images/099.png" style="margin: 0px; 30px;"></td>
        </tr>
        <tr valign=bottom align=center>
            <td>а)</td>
            <td>б)</td>
        </tr>
    </table>
    Архитектура портов: а) ввода, б) вывода<br>
</div>

<p>
    Параллельные интерфейсы микроконтроллеров представляют собой сгруппированные,
    обычно по 8 линий портов, выводы корпуса микросхемы. У контроллеров AVR они называются PORTA, PORTB, PORTC, и т.д..
</p>

<p>
Программно линии портов МК управляются через регистры ввода/вывода. Каждый порт имеет по три регистра: PINX, PORTX, DDRX.
Х – это имя порта, которым управляют эти регистры. Доступ к этим регистрам производится командами
<code style="color: #005599">in</code> и <code style="color: #005599">out</code> через регистры общего назначения.
Это продиктовано RISC-архитектурой построения ядра AVR.
С точки зрения программирования на языке С регистры можно рассматривать
как некие предопределённые переменные, объявленные в стандартном заголовочном файле (<code style="color: #005599">avr/io.h</code>).
Каждый бит в регистре управления однозначно сопоставлен физическому выводу контроллера.
</p>

<p>
    <b>DDRx (Data Direction Register)</b> – регистр направления передачи данных линий порта.
    Логическая “1” для соответствующего разряда означает вывод данных, логический “0” – ввод (по умолчанию).
</p>

<p>
    <b>PORTx</b> – регистр выходных данных, предназначенных для вывода.
    Состояния его разрядов определяют логические уровни на выводах микроконтроллера.
</p>

<p>
    <b>PINx (Port Input Pins)</b> – регистр входных данных, прочитанных с линий порта.
</p>

<div align="center">
    <img src="images/100.png"><br><br>Рис. . Регистры управления портами ввода-вывода
    <br>
</div>

<p>
    К примеру, для вывода данных в порт Х, необходимо регистр DDRx переключить в режим вывода (лог. “1”) а данные переслать в регистр PORTx. Считать значение порта Х можно, если регистр DDRx переключить в режим ввода (лог. “0”), из регистра PINx. Чтобы подключить подтягивающие резисторы в режиме ввода, необходимо установить в лог. “1” соответствующие биты PORTx. Подтягивающие резисторы избавляют от необходимости подключать внешние резисторы к питанию схемы и с помощью одной команды сами подают логическую единицу на вход. Это позволяет избавиться от неопределённости логического сигнала на выводе МК, когда он работает как вход. Если к выводу подключена кнопка, то при отпущенном её состоянии вывод окажется “висящим в воздухе”.
    В этой ситуации МК прочитает помеху. Для исключения подобных ситуаций входы “подтягивают” к линии питания резистором.
</p>

<p>
    Практически все линии портов AVR могут быть использованы для альтернативных функций (аналоговые входы, последовательные интерфейсы, ШИМ-формирователи, и т.д.).
</p>

<p>
    Мощные выходные каскады обеспечивают нагрузочную способность 20 мА на линию порта, что позволяет непосредственно подключать
    к МК светодиоды и биполярные транзисторы. Общая токовая нагрузка на все линии одного порта не должна превышать 80 мА.
</p>

<div align="center">
    <img src="images/101.png"><br><br>Рис. X. Пример включения светодиода
    <br>
</div>

<p>
    В памяти регистров ввода/вывода каждый регистр (DDR, PIN, PORT) имеет свой уникальный адрес, однако воспользоваться этими именами регистров
    в программах на языке Ассемблер возможно при подключении внешних файлов описаний под конкретный тип МК, например
</p>

<pre style="width:400px;"><code>.include    "m2560def.inc"</code></pre>

<p>
    Иначе при обращении к регистрам ввода/вывода придётся использовать реальные адреса памяти данных микроконтроллера, что неудобно.
</p>

<p>
    Для побитного обращения к линиям порта, удобно использовать команды <code style="color: #005599"> sbi, cbi, sbis, sbic</code>...
    Команда <code style="color: #005599"> sbi</code> устанавливает соответствующий бит порта в “1”, а <code style="color: #005599">cbi</code>наоборот – сбрасывает соответствующий бит. Например:
</p>

<pre style="width:400px;">
<code>    ldi R16, 0xFF
    out DDRB, R16 ;все выводы - выходы
    sbi PortB, 5  ;установить на выводе лог. "1"
    cbi PortB, 5  ;сбросить вывод в "0"
</code></pre>

                                        <p>
                                            При замыкании и размыкании кнопок в цепи возникают импульсные помехи, вызванные дребезгом контактов.
                                            Такое явление может восприниматься как многократное нажатие клавиши (см. рис. 1.7). Помехи возникают при установке и разрыве контакта при нажатии на клавишу.
                                        </p>

                                        <div align="center">
                                            <table>
                                                <tr>
                                                    <td><img src="images/102.png" style="margin: 0px 20px;" : 30px;"></td>
                                                    <td><img src="images/103.gif" style="margin-left: 10px;"></td>
                                                </tr>
                                                <tr valign=bottom align=center>
                                                    <td>а)</td>
                                                    <td>б)</td>
                                                </tr>
                                            </table>
                                            Рис. 1.7. а) схема ключа; б) дребезг контактов.<br>
                                        </div>

                                        <p>
                                            Этот эффект устраняется аппаратно, включением параллельно с кнопкой конденсатора небольшой ёмкости, либо программно.
                                            Если уровень напряжения на выходе ключа не изменяется в течении 20мс, то можно считать, что помехи окончились, и больше изменения состояний не ожидается.
                                        </p>
                                        <br><br>

                                        <a name="7.2"></a>
                                        <p class="h3">7.2 Расширение дискретных портов вывода</p>
                                        <br><br>

                                        <a name="7.3"></a>
                                        <p class="h3">7.3 Программно-управляемый ввод/вывод</p>

                                        <p>В ЭВМ применяются три режима ввода/вывода:</p>

                                        <ul>
                                            <li>программно-управляемый ввод/вывод;</li>
                                            <li>ввод/вывод в режиме прерываний;</li>
                                            <li>ввод/вывод в режиме прямого доступа к памяти.</li>

                                        </ul>

                                        <p>
                                            Первый из них характеризуется тем, что инициирование и управление осуществляется программой,
                                            выполняемой процессором, а внешние устройства играют сравнительно пассивную роль и только сигнализируют
                                            о своем состоянии, в частности, о готовности к операциям ввода/вывода. Во втором режиме ввод/вывод инициируется
                                            не процессором, а внешним устройством, генерирующим специальный сигнал прерывания.
                                            Реагируя на этот сигнал готовности устройства к передаче данных, процессор передает управление подпрограмме
                                            обслуживания устройства, вызвавшего прерывание. Действия, выполняемые этой подпрограммой, определяются пользователем,
                                            а непосредственными операциями ввода/вывода управляет процессор. Наконец, в режиме прямого доступа к памяти,
                                            который используется, когда пропускной способности процессора недостаточно, процессор приостанавливается,
                                            он отключается от системной шины и не участвует в передаче данных между основной памятью и быстродействующим ВУ.
                                        </p>

                                        <p>
                                            Программно-управляемый ввод/вывод характеризуется тем,
                                            что все действия по вводу/выводу реализуются командами прикладной программы через порт (рис. 29).
                                            Наиболее простыми эти действия оказываются для «всегда готовых» внешних устройств,
                                            например индикатора на светодиодах. При необходимости ввода/вывода в соответствующем месте программы используются команды <code style="color: #005599">in</code> или <code style="color: #005599">out</code>.
                                            Такая передача данных называется синхронным вводом/выводом (рис. 30, а).
                                        </p>

                                        <div align="center">
                                            <img src="images/078.png"><br>
                                            Рис. 29. Аппаратная реализация программно-управляемого ввода/вывода
                                        </div>

                                        <p>
                                            Однако для большинства ВУ до выполнения операций ввода/вывода необходимо убедиться в их готовности к обмену (рис. 30, б).
                                            Такой режим ввода/вывода называют асинхронным. Общее состояние устройства характеризуется флагом статуса Ready,
                                            называемым также флагом готовности/занятости (Ready/Busy).
                                            Процессор проверяет готовность устройства с помощью команды <code style="color: #005599"> in R,Port_Ready </code>,
                                            выставляет флаги командой <code style="color: #005599">and</code> и осуществляет проверку флагов командами <code style="color: #005599">br</code>.
                                            Если флаг Ready установлен, то инициируются собственно ввод или вывод данных из порта Data.
                                            Когда же флаг сброшен, процессор выполняет цикл из 2–3 команд с повторной проверкой флага Ready до тех пор,
                                            пока устройство не будет готово к операциям ВВ. Данный цикл называется циклом ожидания готовности ВУ.
                                        </p>

                                        <div align="center">
                                            <table>
                                                <tr>
                                                    <td><img src="images/079.gif"></td>
                                                    <td>
                                                        <pre style="width:150px;"><code>

in R,Port_Data
                                                                                     </code>
                                                            </pre>
                                                    </td>
                                                    <td><img src="images/080.gif" style="margin-left: 30px;"></td>
                                                    <td>
                                                        <pre style="width:170px;"><code>

M0: in R,Port_Ready
    sbrs R,Bit_Ready
    rjmp M0
    in R,Port_Data

                                                                                      </code>
                                                            </pre>
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>  </td>
                                                    <td>а</td>
                                                    <td>  </td>
                                                    <td>б</td>
                                                </tr>
                                            </table>

                                            Рис.30. Выполнение операций ввода/вывода: <br>
                                            а – синхронный, б – асинхронный
                                        </div>

                                        <p>
                                            Основной недостаток программного ввода/вывода связан с непроизводительными потерями времени процессора в циклах ожидания.
                                            К достоинствам следует отнести простоту его реализации, не требующей дополнительных аппаратных средств.
                                        </p>

                                        <br><br>
                                        <a name="7.4"></a>
                                        <p class="h3">7.4 Ввод/вывод в режиме прерываний</p>

                                        <p>
                                            Непроизводительные потери процессорного времени на ожидание наступления события можно исключить,
                                            если эту задачу возложить на специальный аппаратный контроллер, который бы автоматически сообщал программе
                                            о моменте появления события, прерывая её выполнение и вызывая функцию-обработчик.
                                            Такой механизм называется прерыванием.
                                        </p>

                                        <div align="center">
                                            <table>
                                                <tr>
                                                    <td><img src="images/104.png" style="margin: 0px 10px;" : 30px;"></td>
                                                    <td><img src="images/105.png" style="margin: 0px; 30px;"></td>
                                                </tr>
                                                <tr valign=bottom align=center>
                                                    <td>а)</td>
                                                    <td>б)</td>
                                                </tr>
                                            </table>
                                            Рис.Х. Модель механизма ввода-вывода:<br>
                                            а) с программным опросом; б) в режиме с прерываниями
                                        </div>

                                        <p>
                                            Это быстрая реакция микроконтроллера на внешнее или
                                            внутреннее событие вне зависимости от выполняемого в данный момент кода.
                                            Под реакцией подразумевается выполнение некой функции, обрабатывающей прерывание.
                                            Главное отличие ввода/вывода в режиме с прерыванием от программного ввода/вывода состоит в том, что:
                                        </p>
                                        <p>1) инициатором является внешний сигнал;</p>
                                        <p>2) заранее не известно, в какой момент будет прервана текущая программа.</p>

                                        <div align="center" style="float: right; margin-left: 20px">
                                            <table>
                                                <tr>
                                                    <td><img src="images/081.png" style="margin: 0px 10px 20px 0px;"><br> Рис.31. Реакция на прерывание</td>
                                                    <td>
                                                        <pre style="width:250px;"><code>
    push SREG; 	stack - (F)
    push РОН
    …; (операции ввода/вывода)

    pop РОН
    pop SREG
    reti        </code>        </pre>
                                                    </td>
                                            </table>
                                        </div>

                                        <p>
                                            При этом каждое периферийное устройство может посылать в процессор сигнал запроса прерывания INTerrupt,
                                            когда оно готово к операциям ввода/вывода. По существу, этот сигнал представляет собой выходной сигнал триггера,
                                            фиксирующего флаг готовности READY. Сигнал INT появляется в произвольные моменты времени, асинхронно по отношению к действиям процессора,
                                            и управлять его появлением программа не может. Следовательно, заранее не известно, в какой точке программы,
                                            и какие периферийные устройства инициируют прерывания, поэтому непосредственно в программе команды ввода/вывода использовать нельзя.
                                            Реагируя на сигнал INT, процессор должен прервать, т.е. временно приостановить текущую программу, идентифицировать прерывающее устройство,
                                            перейти к подпрограмме обслуживания прерываний работы этого устройства, а после её завершения возобновить выполнение прерванной программы.
                                            Подпрограмме обслуживания потребуются внутренние регистры процессора: счётчик команд, некоторые РОН, регистр состояния,
                                            и их текущее содержимое будет модифицировано. Но прерванная программа должна возобновиться так, будто прерывания вообще не было (рис. 31).
                                        </p>
                                        <p>
                                            При этом содержимое всех регистров, необходимых подпрограмме, следует временно запоминать.
                                            В качестве такого временного «хранилища» удобно использовать стек. Предпочтительными с точки зрения повышения производительности микроЭВМ
                                            являются уменьшение числа команд, обеспечивающих сохранение информации о прерванной программе, и реализация этих функций аппаратными средствами.
                                            Существуют процессоры с несколькими банками регистров общего назначения (например, Z80). При обработке прерываний банки переключаются с основного
                                            на дополнительный, что позволяет избежать сохранения содержимого регистров в стеке (ортогональная регистровая архитектура).
                                        </p>
                                        <p>
                                            Факт обслуживания прерывания влияет на прерванную программу только увеличением времени её выполнения,
                                            поэтому подпрограмма обслуживания должна быть как можно короче.
                                        </p>
                                        <p>
                                            В МК AVR механизмом перываний управляет ряд регистров в области ввода/вывода оперативной памяти данных.
                                            Управление работой контроллера прерываний на глобальном уровне производится флагом I регистра статуса SREG.
                                            Для этого МК AVR имеют специальные команды:
                                        </p>

                                        <div align="center">
                                            <table>
                                                <tr>
                                                    <td>
                                                        <pre style="width:350px;"><code>
sei ;установка флага I – разрешить прерывания
cli ;сброс флага I – запретить прерывания

</code></pre>
                                                </tr>
                                            </table>
                                        </div>


                                        <div align="center" style="margin:20px 0"><img src="images/082.png"></div>

                                        <p>
                                            По умолчанию бит I SREG сброшен, т.е. прерывания при запуске МК запрещены.
                                            Чтобы их разрешить, необходимо в процедуре начальной инициализации, выполняющейся по сбросу МК,
                                            разместить команду <code style="color: #005599">sei</code>, которая установит флаг I в “1”.
                                        </p>

                                        <p>
                                            События от периферийных устройств такие, к примеру, как смена логического уровня на определённых выводах МК,
                                            достижение таймером-счётчиком максимального значения, завершение преобразования в АЦП или появление новых данных в буфере
                                            последовательного интерфейса, аппаратно фиксируются флагами INT Flags в управляющих регистрах. Затем, если данное прерывание
                                            разрешено локально битами Enable Interrupt, переход к обработчику производится немедленно.
                                        </p>

                                        <p>
                                            Рассмотрим механизм внешних прерываний. Они осуществляются через выводы INT7:0 и будут генерироваться,
                                            даже если указанные линии настроены как выходы. Для каждого события есть свой флаг запроса.
                                            Для однородных событий, в том числе таких, как внешние прерывания, они собраны в регистры. Например,
                                            регистр флагов внешних прерываний EIFR (External Interrupt Flag Register) выглядит так:
                                        </p>

                                        <div align="center"><img src="images/083.png"></div>

                                        <p>
                                            При поступлении импульса, к примеру, на вывод INT1 установится флаг INTF1,
                                            т.е. разряд EIFR[1]. Но это не значит, что запрошенное прерывание произойдёт.
                                            Это возможно только если оно разрешено на двух уровнях: глобально флагом I в
                                            регистре SREG и локально – битом INT1 в регистре масок внешних прерываний EIMSK (External Interrupt Mask Register):
                                        </p>

                                        <div align="center"><img src="images/084.png"></div>

                                        <p>
                                            При использовании внешних прерываний биты, соответствующие заданным прерываниям необходимо устанавить в “1”,
                                            иначе автоматического прерывания текущей программы не произойдёт. Разрешить внешнее прерывание с вывода INT1 можно следующим образом:
                                        </p>


                                        <table>
                                            <tr>
                                                <td>
                                                    <pre style="width:450px;"><code>
in R16,EIMSK       ;Загрузить в R16 текущее состояние EIMSK
ori R16,(1<< INT1) ;Битовая маска 0b00000010; INT1=1
out EIMSK,R16      ;Записать R16 в EIMSK
sei                ;Разрешить глобально все прерывания

</code></pre>
                                            </tr>
                                        </table>


                                        <p>
                                            В МК AVR внешние прерывания могут генерироваться по фронту либо спаду импульса,
                                            а также по низкому либо высокому логическому уровню. Желаемый вариант выбирается битами ISCn1,
                                            ISCn0 (Interrupt Sense Control bits) в регистрах EICRA, EICRB:
                                        </p>

                                        <div align="center"><img src="images/085.png"></div>
                                        <br>
                                        <div align="center"><img src="images/086.png"></div>

                                        <p>
                                            в соответствии с таблицей:
                                        </p>

                                        <br>
                                        <center>
                                            <table border="1" cellpadding="4" cellspacing="1">
                                                <tr align=center bgcolor="#D1D6E9">
                                                    <th class="tc">№ Бита</th>
                                                    <th class="tc">Название</th>
                                                    <th colspan="3" class="tc">Описание</th>
                                                </tr>
                                                <tr bgcolor=#EAEAEA>
                                                    <td rowspan="6" class="tc">3,2</td>
                                                    <td rowspan="6" class="tc">ICS11, ICS10</td>
                                                    <td colspan="3" valign="middle" class="tc">Определяют условие генерации внешнего прерывания INT1:</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">ICS11</td>
                                                    <td class="tc">ICS10</td>
                                                    <td class="tc">Условие</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">0</td>
                                                    <td class="tc">0</td>
                                                    <td class="tc">По низкому уровню на выводе INT1</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">0</td>
                                                    <td class="tc">1</td>
                                                    <td class="tc">Зарезервировано</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">1</td>
                                                    <td class="tc">0</td>
                                                    <td class="tc">По спаду импульса на выводе INT1</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">1</td>
                                                    <td class="tc">1</td>
                                                    <td class="tc">По фронту импульса на выводе INT1</td>
                                                </tr>
                                                <tr bgcolor=#EAEAEA>
                                                    <td rowspan="6" class="tc">1,0</td>
                                                    <td rowspan="6" class="tc">ICS01, ICS00</td>
                                                    <td colspan="3" valign="middle" class="tc">Определяют условие генерации внешнего прерывания INT0:</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">ICS01</td>
                                                    <td class="tc">ICS00</td>
                                                    <td class="tc">Условие</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">0</td>
                                                    <td class="tc">0</td>
                                                    <td class="tc">По низкому уровню на выводе INT0</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">0</td>
                                                    <td class="tc">1</td>
                                                    <td class="tc">Зарезервировано</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">1</td>
                                                    <td class="tc">0</td>
                                                    <td class="tc">По спаду импульса на выводе INT0</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">1</td>
                                                    <td class="tc">1</td>
                                                    <td class="tc">По фронту импульса на выводе INT0</td>
                                                </tr>
                                            </table>
                                        </center>
                                        <br>

                                        <p>
                                            Для реакции на спад импульса, к примеру,
                                            при нажатии на кнопку необходимо, чтобы ISCn1=1, ISCn=0. Это можно настроить командами:
                                        </p>

                                        <table>
                                            <tr>
                                                <td>
                                                    <pre style="width:450px;"><code>
ldi R16,0b00001000  ; Настройка условия генерации прерывания
sts EICRA,R16       ; по спаду сигнала на входе INT1

</code></pre>
                                            </tr>
                                        </table>

                                        <p>
                                            Теперь при смене высокого уровня на низкий на выводе INT1 произойдёт прерывание текущей программы,
                                            автоматически сохранится в стеке содержимое счётчика команд PC и в него загрузится адрес соответствующего вектора прерывания ($0004).
                                            По этому адресу, должна находиться команда безусловного перехода к подпрограмме обработки прерывания (Interrupt Service Routine, ISR).
                                            Последней командой подпрограммы обработки прерывания должна быть <code style="color: #005599">reti</code>, которая обеспечивает возврат в основную программу восстанавливая предварительно
                                            сохранённый счётчик команд.
                                        </p>



                                        <p>
                                            Вектор прерывания – это фиксированный именной адрес, за которым закреплено внешнее событие,
                                            по наступлению которого МК прерывает свою работу и загружает этот адрес в счётчик команд.
                                            Все вместе эти адреса образуют таблицу векторов прерывания. Обычно она расположена в самом начале памяти программ.
                                            Для ATmega328p таблица прерываний включает 26 векторов и выглядит следующим образом:
                                        </p>

                                        <br>
                                        <center>
                                            <table border=1 cellpadding="4" cellspacing="1">
                                                <tr align=center bgcolor="#D1D6E9">
                                                    <td class="tcb">№</td>
                                                    <td class="tcb">Адрес</td>
                                                    <td class="tcb">Источник</td>
                                                    <td class="tcb">Описание</td>
                                                </tr>
                                                <tr bgcolor=#DCDCDC>
                                                    <td class="tc">1</td>
                                                    <td class="tc">$0000</td>
                                                    <td class="tc">RESET</td>
                                                    <td class="tc">Сброс</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">2</td>
                                                    <td class="tc">$0002</td>
                                                    <td class="tc">INT0</td>
                                                    <td class="tc">Внешнее прерывание 0</td>
                                                </tr>
                                                <tr bgcolor=#DCDCDC>
                                                    <td class="tc">3</td>
                                                    <td class="tc">$0004</td>
                                                    <td class="tc">INT1</td>
                                                    <td class="tc">Внешнее прерывание 1</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">4</td>
                                                    <td class="tc">$0006</td>
                                                    <td class="tc">PCINT0</td>
                                                    <td class="tc">Pin Change Interrupt Reqest 0</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">5</td>
                                                    <td class="tc">$0008</td>
                                                    <td class="tc">PCINT1</td>
                                                    <td class="tc">Pin Change Interrupt Reqest 1</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">6</td>
                                                    <td class="tc">$000A</td>
                                                    <td class="tc">PCINT2</td>
                                                    <td class="tc">Pin Change Interrupt Reqest 2</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">7</td>
                                                    <td class="tc">$000C</td>
                                                    <td class="tc">WDT</td>
                                                    <td class="tc">Watchdog Time-out Interrupt</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">8</td>
                                                    <td class="tc">$000E</td>
                                                    <td class="tc">TIMER2 COMPA</td>
                                                    <td class="tc">Совпадение «А» таймера/счётчика Т2</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td colspan="4" style="text-align:center">
                                                        ...
                                                    </td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">26</td>
                                                    <td class="tc">$0032</td>
                                                    <td class="tc">SPM_RDY</td>
                                                    <td class="tc">Готовность SPM</td>
                                                </tr>
                                            </table>
                                        </center>
                                        <br>

                                        <p>
                                            В программном выражении:
                                        </p>


                                        <table>
                                            <tr>
                                                <td>
                                                    <pre style="width:480px;"><code>
.org $0000 jmp RESET    ;Reset Handler
.org $0002 jmp Ext_INT0 ;(INT0) Запрос внешнего прерывания 0
.org $0004 jmp Ext_INT1 ;(INT1) Запрос внешнего прерывания 1
.org $0006 reti PCINT0  ;Pin Change Interrupt Reqest 0
.org $0008 reti PCINT1  ;Pin Change Interrupt Reqest 1
.org $000A reti PCINT2  ;Pin Change Interrupt Reqest 2
.org $000C reti WDT     ;Watchdog Time-out Interrupt
.org $000E reti TIMER2_COMPA ;Timer/Counter2 Compare Match A
                .  .  .  .  .  .  .
.org $0032 reti         ;(SPM_RDY) Готовность Store Program Memory
.org $INT_VECTORS_SIZE  ;конец таблицы прерываний

</code></pre>
                                            </tr>
                                        </table>


                                        <p>
                                            Положение вектора в таблице также определяет и приоритет соответствующего прерывания:
                                            чем меньше адрес, тем выше приоритет. Размер вектора прерывания составляет 2 ячейки памяти и
                                            позволяет поместить туда команду <code style="color: #005599">jmp</code>. Если прерывания в работе микроконтроллера не предусматриваются,
                                            то на месте таблицы может быть размещена часть основной программы.
                                        </p>

                                        <p>
                                            Таблица векторов прерываний начинается с указания реакции на событие RESET по адресу $0000,
                                            иначе МК будет выполнять команды из таблицы векторов прерываний, что вызовет непредсказуемые последствия.
                                            По метке RESET должна располагаться инициализация указателя стека Stack Pointer (SP), который определяет
                                            расположение области памяти для хранения адресов возвратов и состояния процессора. Обычно стек расположен по
                                            последнему адресу резидентной памяти данных (RAMEND) и растёт в сторону уменьшения адресов.
                                        </p>


                                        <table>
                                            <tr>
                                                <td>
                                                    <pre style="width:450px;"><code>
RESET:	ldi R16,Low(RAMEND)	; Инициализация стека
        out SPL,R16
        ldi R16,High(RAMEND)
        out SPH,R16
</code></pre>
                                            </tr>
                                        </table>


                                        <p>
                                            Для неиспользуемых прерываний необходимо прописать команды-заглушки <code style="color: #005599">reti</code>, иначе непреднамеренное прерывание приведёт к краху программы.
                                            Для ATmega328p конец таблицы прерываний задан в файле m328pdef.inc в виде константы INT_VECT0RS_SIZE (поскольку $32 = 5210):
                                        </p>


                                        <table>
                                            <tr>
                                                <td>
                                                    <pre style="width:450px;"><code>
.equ INT_VECTORS_SIZE = 52	; words size

</code></pre>
                                            </tr>
                                        </table>


                                        <p>
                                            МК AVR имеют время отклика на прерывание 4 периода тактовой частоты.
                                            Если прерывание происходит во время выполнения длинной команды,
                                            эта команда корректно завершается до начала обработки прерывания.
                                            Возврат из прерывания также занимает 4 периода тактовой частоты.
                                        </p>

                                        <p>
                                            Таким образом, алгоритм обработки прерывания в общем виде (и конкретно для внешних прерываний) включает следующие шаги:
                                        </p>

                                        <p>
                                            1. Произошло событие А.
                                        </p>
                                        <p>
                                            2. Установился флаг на запрос прерывания А (бит INTF в регистре EIFR).
                                        </p>

                                        <p>
                                            3. Если данное прерывание разрешено (бит INT в регистре EIMSK), то флаг А обнаружен МК.
                                        </p>

                                        <p>
                                            4. МК сбрасывает флаг I в регистре SREG, запретив глобально все прерывания.
                                        </p>

                                        <p>
                                            5. МК определяет номер вектора прерывания.
                                        </p>

                                        <p>
                                            6. МК вычисляет адрес соответствующего вектора прерывания.
                                        </p>

                                        <p>
                                            7. МК сбрасывает флаг на запрос прерывания A (бит INTF в регистре EIFR).
                                        </p>

                                        <p>
                                            8. Перед тем, как уйти на обработку прерывания, МК аппаратно сохраняет адрес возврата в стеке, уменьшая содержимое регистра SP на 2.
                                        </p>

                                        <p>
                                            9. В счётчик команд записывается адрес вектора прерывания: PC - Вектор А (PC - $0004).
                                        </p>

                                        <p>
                                            А там записано:
                                        </p>

                                        <table>
                                            <tr>
                                                <td>
                                                    <pre style="width:650px;"><code>
00XX:   jmp Метка_Обработки_События_А
	...
Метка_Обработки_События_А:
		/* Обработчик прерывания ISR */
	push R16   ;Сохранение в стеке R16, т.к. он будет использован в обработчике прерывания
	in R16,SREG
	push R16   ;Сохранение в стеке SREG
	...
	pop R16    ;Восстановление SREG и R16
	out SREG,R16
	pop R16
	reti       ;Возврат из обработчика прерывания

</code></pre>
                                            </tr>
                                        </table>


                                        <p>
                                            В начале подпрограмма обработки прерывания сохраняет в стеке регистры,
                                            которые будут использоваться самой подпрограммой (r16). В конце подпрограммы эти регистры
                                            восстанавливаются из стека командой <code style="color: #005599">pop</code>. Обработчик прерывания всегда заканчивается командой
                                            <code style="color: #005599">reti</code> – Return from Interrupt, по которой восстанавливается содержимое счётчика команд PC и
                                            устанавливается общий флаг разрешения прерываний I - “1”.
                                        </p>

                                        <p>
                                            Если во время обработки прерывания произошли ещё какие-то прерывания, то их флаги окажутся установленными,
                                            и процедуры их обработки начнут выполняться незамедлительно в том порядке, в каком они расположены в таблице
                                            векторов прерываний. При такой системе “потерять” прерывание можно только при большой загрузке МК, когда события
                                            следуют чаще, чем успевают обрабатываться.
                                        </p>

                                        <p>
                                            Так как прерывания отвлекают процессор от основной программы и блокируют другие прерывания,
                                            то обработчик прерывания должен выполняться максимально быстро. Здесь недопустимы циклы задержки и долгие процедуры.
                                        </p>

                                        <p>
                                            Другая особенность связана с неразрывными операциями. Например, чтение 16-разрядных регистров таймера или 10-разрядного регистра
                                            АЦП в 8-разрядные РОН. Такие операции предусматривают два этапа: сначала младший байт, а потом старший. Между считыванием младшего
                                            и старшего байта прерывание недопустимо, т.к. после выхода из прерывания в таймере уже будет неактуальная информация. Поэтому перед
                                            чтением необходимо запрещать прерывания либо глобально (<code style="color: #005599">cli</code>), а затем – разрешать (<code style="color: #005599">sei</code>), либо локально.
                                        </p>

                                        <br><br>
                                        <a name="7.5"></a>
                                        <p class="h3">7.5 Ввод/вывод в режиме прямого доступа к памяти</p>

                                        <p>
                                            Этот метод используется для скоростных внешних запоминающих устройств (ВЗУ), таких, например, как накопители на жестких магнитных дисках,
                                            или устройств отображения информации на экране. В них обмен производится блоками фиксированного размера от 128 байт и более,
                                            причём этот обмен должен осуществляться в строгой последовательности без пропусков, так как пропуск хотя бы одного байта вызовет
                                            необходимость в повторном обмене. При этом время, отводимое на обмен одним байтом, строго ограничено скоростью перемещения магнитного
                                            носителя относительно магнитных головок и не превышает, как правило, нескольких микросекунд. Например, ЖКИ 128×128 пикселов и 256 цветов,
                                            применяемый в мобильных телефонах, формирует полный кадр изображения за 36мкс. Это означает, что за секунду может быть обновлено 27,7 кадров,
                                            хранящихся в ОЗУ. Обеспечить обмен большими блоками данных с ВУ как при помощи программно-управляемого обмена, так и в режиме прерываний процессора
                                            невозможно, так как на обмен каждым байтом затрачивается несколько команд, суммарное время выполнения которых превышает допустимое время на обмен одним байтом с ВУ.
                                        </p>

                                        <p>
                                            Поэтому высокоскоростной обмен производится в режиме прямого доступа к памяти (ПДП, DMA) без участия процессора.
                                            При этом ряд функций реализуется аппаратно, а время обмена одним байтом данных равно одному циклу обращения к памяти.
                                            Причём обменом управляет не программа, а специальный контроллер прямого доступа к памяти.
                                        </p>

                                        <p>
                                            Существует две разновидности ПДП. В режиме “прозрачного ПДП” передача данных выполняется без информирования процессора,
                                            для чего используются те интервалы машинных циклов, когда процессор не обращается к памяти, а выполняет внутренние преобразования данных.
                                            Такими интервалами в процессоре КР580 являются такты Т4 и Т5 (части цикла, используемые для внутренних операций).
                                            Процессор идентифицирует эти интервалы специальным сигналом, означающим доступность системной шины.
                                            Производительность процессора в таком режиме не уменьшается, но сами передачи носят нерегулярный характер,
                                            что ведет к уменьшению скорости передачи данных.
                                        </p>

                                        <p>
                                            Другим способом является “ПДП с приостановкой процессора”, при котором выполнение команд задерживается на несколько тактов.
                                            Как показано на рис. 33, контроллер непосредственно связан с памятью микроЭВМ через шины данных и адреса.
                                            При этом возникает проблема совместного использования шин процессором и контроллером ПДП.
                                            Для исключения конкуренции двух устройств за право владения шиной контроллер ПДП снабжен двумя управляющими линиями:
                                            “Захват шин” (HOLD) и “Подтверждение захвата” (HLDA).
                                        </p>

                                        <div align="center">
                                            <br>
                                            <img src="images/087.png" title="Организация ввода/вывода в режиме ПДП"><br>
                                            Рис.33. Организация ввода/вывода в режиме ПДП
                                            <br>
                                        </div>

                                        <p>
                                            Если требуется обмен данными, то периферийное устройство адресует запрос обмена (сигнал DRQ) контроллеру ПДП.
                                            После получения от устройства такого запроса контроллер ПДП посылает на вход HOLD микропроцессора сигнал “Захват шин”.
                                            Процессор, получив этот сигнал, приостанавливает выполнение очередной команды (закончив очередной машинный цикл),
                                            отключается от шин системного интерфейса (путем перехода шин в состояние высокого сопротивления) и выдает на системный
                                            интерфейс управляющий сигнал “Подтверждение захвата”. С этого момента все шины управляются контроллером ПДП,
                                            который осуществляет обмен побайтно или блоками данных с памятью микроЭВМ и затем, сняв сигнал захвата, контроллер
                                            возвращает управление системным интерфейсом процессору. Как только контроллер ПДП будет готов к обмену следующим блоком данных,
                                            он вновь “захватывает” цикл процессора и т.д. В промежутках между сигналами подтверждения процессор может продолжать выполнение команд программы.
                                            Тем самым выполнение программы замедляется, но в меньшей степени, чем при обмене в режиме программного ввода/вывода.
                                        </p>

                                        <p>
                                            Применение в микроЭВМ режима ПДП всегда требует предварительной подготовки, а именно:
                                            для каждого ВУ необходимо выделить область памяти, используемую при обмене, и указать её размер,
                                            т.е. число данных, подлежащих пересылке. Следовательно, контроллер ПДП должен обязательно иметь в своём составе регистр адреса и счётчик байт.
                                            Перед началом обмена в режиме ПДП необходимо выполнить подготовительные операции по записи в указанные регистры контроллера ПДП начального
                                            адреса выделенной внешнему устройству памяти и её объема в байтах или словах в зависимости от того, какими порциями информации ведётся обмен.
                                        </p>

                                        <br><br>
                                        <a name="7.6"></a>
                                        <p class="h3">7.6 Аналоговые порты ввода</p>

                                        <p>
                                            Для преобразования аналоговых сигналов о таких физических величинах,
                                            как температура, давление, влажность, скорость, ускорение, и т.д.
                                            в цифровой код, который может обработать МК служит аналогово-цифровой преобразователь (АЦП).
                                            Однако он способен измерять только напряжение, поэтому чтобы произвести измерение физической величины,
                                            её необходимо вначале преобразовать в напряжение.
                                        </p>

                                        <div align="center">
                                            <img src="images/088.png" title="Обработка аналоговых величин"><br>
                                            Рис. Х. Обработка аналоговых величин
                                        </div>

                                        <p>
                                            Одной из важнейших характеристик АЦП, которая влияет на точность измерения,
                                            является разрешающая способность. При этом весь диапазон измерения, от нуля до максимума, т.е. до
                                            напряжения источника опорного напряжения (ИОН)<code style="color: #005599">V<sub>ref</sub></code>, равномерно разбивается на части. Для 8
                                            битного АЦП это 2<Sup>8</Sup>=256 значений, для 10 битного
                                            2<Sup>10</Sup>=1024. Каждое значение, или шаг квантования, соответствует
                                            шагу шкалы измеряемого напряжения.
                                        </p>

                                        <p style="text-align: right;">Таблица 4
                                        <p>

                                        <p style="text-align: center;">
                                            Разрешающая способность АЦП (V<sub>ref</sub> =
                                            V<sub>cc</sub> = 5V)
                                        </p>
                                        <center>
                                            <table border=1 cellpadding="1" cellspacing="1">
                                                <tr align=center bgcolor="#D1D6E9">
                                                    <td class="tcb">n-бит</td>
                                                    <td class="tcb">Количество шагов</td>
                                                    <td class="tcb">Разрешение, мВ</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">8</td>
                                                    <td class="tc">256</td>
                                                    <td class="tc">5/256=19,53</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">10</td>
                                                    <td class="tc">1024</td>
                                                    <td class="tc">5/1024=4,88</td>
                                                </tr>
                                                <tr bgcolor="#EAEAEA">
                                                    <td class="tc">12</td>
                                                    <td class="tc">4096</td>
                                                    <td class="tc">5/4096=1,2</td>
                                                </tr>
                                                <tr bgcolor="#DCDCDC">
                                                    <td class="tc">16</td>
                                                    <td class="tc">65536</td>
                                                    <td class="tc">5/65536=0,076</td>
                                                </tr>
                                            </table>
                                        </center>
                                        <br><br>

                                        <p>
                                            Из таблицы следует, что чем выше разрешение (n = 8, 10, 12, 16), тем меньше
                                            величина шага, и тем выше точность. Таким образом, разрешение – это
                                            наименьшее изменение входного сигнала, которое способен распознать АЦП.
                                        </p>

                                        <p>
                                            Практически во всех современных микроконтроллерах, в том числе и AVR имеется
                                            10 битный АЦП последовательного приближения. На практике два младших
                                            разряда сильно чувствительны к шуму, поэтому обычно принимают во внимание
                                            только 8 старших разрядов.
                                        </p>

                                        <p>
                                            Величина разрешения может регулироваться значением опорного напряжения V<sub>ref</sub>,
                                            которое может быть выбрано тремя способами: подключено извне к
                                            выводу AREF, или к выводу AVCC (Analog V<sub>cc</sub>) или же может
                                            использоваться внутренний ИОН напряжением 2,56В.
                                        </p>

                                        <p>
                                            Для расширения диапазона измерения применяют делитель напряжения. Например,
                                            если максимальное измеряемое напряжение 10В, а опорное напряжение 5В,
                                            то чтобы расширить диапазон измерения, нужно уменьшить измеряемый сигнал в 2
                                            раза.
                                        </p>

                                        <p>Формула для расчёта делителя выглядит следующим образом:</p>

                                        <p>
                                            U<sub>вых</sub> = U<sub>вх</sub>*R<sub>2</sub>/(R<sub>1</sub> + R<sub>2</sub>).
                                        </p>

                                        <p>Подставим значения в формулу:</p>

                                        <p>
                                            5 = 10*R<sub>2</sub>/(R<sub>1</sub>+R<sub>2</sub>)<br>
                                            (R<sub>1</sub>+R<sub>2</sub>)=2*R<sub>2</sub><br>
                                            R<sub>1</sub>=R<sub>2</sub>
                                        </p>

                                        <p>
                                            т.е. можно взять любые два одинаковых резистора и подключить их по
                                            нижеприведённой схеме.
                                        </p>

                                        <div style="float: right; margin-left: 10px">
                                            <img src="images/089.png" title="Делитель напряжения"><br>
                                            Рис. Х. Делитель напряжения<br>
                                        </div>

                                        <p>Следовательно, при измерении напряжения через делитель, нужно полученное значение АЦП умножить на коэффициент <i>Uвых/Uвх</i>.</p>

                                        <p>Полная формула вычисления измеряемого напряжения будет выглядеть так:</p>

                                        <p>
                                            U=(опорное напряжение * значение АЦП * коэффициент делителя)/число разрядов
                                            АЦП
                                        </p>

                                        <p>
                                            <i>Пример:</i> опорное 5В, измеренное значение АЦП = 512, коэффициент
                                            делителя =2, АЦП 10-разрядный.<br>

                                            (5*512*2)/1024=5В – реальное измеренное значение напряжения.
                                        </p>

                                        <p>
                                            Результат преобразования представляет собой восьми либо десятиразрядный
                                            цифровой код. Число на выходе, соответствующее определённому напряжению
                                            на входе, вычисляется по формуле:
                                        </p>

                                        <p><i>D<sub>out</sub> = V<sub>in</sub> / Step_size ,</i>
                                        <p />

                                        <p>
                                            где D<sub>out</sub> – число на выходе (в десятичном коде), V<sub>in</sub> –
                                            входное напряжение, <i>Step_size</i> (разрешение) – это
                                            <i>Vref/n</i> для n-разрядного АЦП. Например, определим значение выхода для
                                            входных напряжений 1,7В и 2,1В для 8-разрядного АЦП с опорным
                                            напряжением 2,56В.
                                        </p>

                                        <p>
                                            Step_size = 2,56/256 = 10мВ.<br>

                                            а) D<sub>out</sub> = 1,7V/10 mV = 170 &#8594; 0b10101010<br>

                                            б) D<sub>out</sub> = 2.1V/10 mV = 210 &#8594; 0b11010010.
                                        </p>

                                        <p>
                                            Другой важной характеристикой является время преобразования аналоговой
                                            величины на входе в цифровой выход. Она определяется вариантом схемы АЦП,
                                            тактовой частотой на входе АЦП, а также используемым методом преобразования.
                                            Чтобы обеспечить 10-разрядную точность, частота на которой работает
                                            АЦП должна быть в пределах 50..200 кГц. При этом первое преобразование
                                            занимает 25 циклов и 13 циклов далее. Таким образом, при частоте 200кГц
                                            можно производить максимум 200000/13 = 15384 измерения в секунду.
                                        </p>
										
										<div align="center" style="float: right; margin: 0px 20px">
                                            <img src="images/122.png"><br>
                                        </div>

                                        <p>
                                            Обычно МК с АЦП обычно имеют более одного аналогового входа. Количество входных каналов, к примеру, в ATmega 256 достигает 16.
                                            Тот или иной вход выбирается мультиплексором. Это позволяет с помощью одного АЦП измерять сигналы от нескольких источников.
                                        </p>

                                        <p>
                                            С программной точки зрения АЦП в МК AVR, как и другие периферийные устройства,
                                            управляется пятью регистрами ввода/вывода. Для ATmega328p это:
                                        </p>

                                        <ul>
                                            <li>
                                                <b>ADCL</b> (A/D Result Low) и ADCH (A/D Result High), восьмибитные регистры, где хранится результат преобразования;
                                            </li>
                                            <li><b>ADMUX</b> (ADC MUltipleXer selection register);</li>
                                            <li><b>ADCSRA</b> и <b>ADCSRB</b> (ADC Control and Status Register).</li>

                                        </ul>

                                        <p>
                                            <b>Регистр ADMUX</b> управляет выбором
                                            канала АЦП, источника опорного напряжения и способом выравнивания
                                            результата.
                                        </p><br>

                                        <div align="center" style="float: margin: 10px 20px">
                                            <img src="images/092.png" title="Регистр ADMUX"><br>
                                            Рис. Х. Регистр ADMUX
                                        </div>
                                        <br><br><br>

                                        <p>
                                            <i>Биты 7:6 - REFS1:0: Reference Selection Bits</i> – выбор источника
                                            опорного напряжения.
                                        </p>

										<div align="left" style="float: left; margin: 10px 20px">
                                            <img src="images/093.png"><br>
                                        </div>

										<br>
                                        <table border=1 cellpadding="1" cellspacing="1" align="center">
                                            <tr align=center bgcolor="#D1D6E9">
                                                <td class="tcb">REFS1</td>
                                                <td class="tcb">REFS0</td>
                                                <td class="tcb">Источник Vref</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">0</td>
                                                <td class="tc">0</td>
                                                <td class="tc">Внешний вывод AREF</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">0</td>
                                                <td class="tc">1</td>
                                                <td class="tc">Внешний вывод питания аналоговой части AVCC</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">1</td>
                                                <td class="tc">0</td>
                                                <td class="tc">Не используется</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">1</td>
                                                <td class="tc">1</td>
                                                <td class="tc">Внутренний ИОН 1,1 В</td>
                                            </tr>
                                        </table>
                                        <br>

                                        <p>
                                            Примечание. Если в ATmega 328p ИОН имеет опорное напряжение 1,1В, то у ATmega 2560 опорное напряжение 2,56В. При опорном напряжении 2,56В, разрешение составит достаточно круглое число 2,56В/1024 = 2,5mV, что упростит
                                            вычисления.
                                        </p>

                                        <p>Однако если вывод VREF подключён ко внешнему опорному источнику, то в данном приложении нельзя будет использовать никакие другие опорные напряжения, иначе они будут закорочены на внешнее напряжение.</p>

                                        <p>
                                            <i>Бит 5 - ADLAR: ADC Left Adjust Result</i> – выравнивание результата влево или вправо. ЦАП имеет 10-разрядный выход, значит, он не помещается в байтовый регистр. Поэтому измеренное значение хранится в 2-байтовом регистре, в
                                            котором используются только 10 бит из 16. Остальные 6 не используются. Это могут быть 6 левых или 6 правых битов в зависимости от значения бита ADLAR:
                                        </p>
										
										<div align="center" style="float: center; margin: 20px 20px">
                                            <img src="images/094.png" title="Выравнивание данных влево/вправо"><br>
											Рис. Х. Выравнивание данных влево/вправо
                                        </div>
										
                                        <p>На практике, удобно установить ADLAR = 1, тогда результат смещается влево, и только старший байт ADCH считается результатом.</p>

                                        <p><i>Биты 4:0 - MUX4:0: Analog Channel and Gain Selection Bits</i> – выбор аналогового входа, подключенного ко входу АЦП согласно таблицы.</p>
 
										<div align="center" style="float: left; margin: 10px 20px">
                                            <img src="images/095.png"><br>
                                        </div>

										<br>
                                        <table border=1 cellpadding="1" cellspacing="1" align="center">
                                            <tr align=center bgcolor="#D1D6E9">
                                                <td class="tcb">MUX 4..0</td>
                                                <td class="tcb">Вход АЦП</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">00000</td>
                                                <td class="tc">ADC0</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">00001</td>
                                                <td class="tc">ADC1</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">00010</td>
                                                <td class="tc">ADC2</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">00011</td>
                                                <td class="tc">ADC3</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">00100</td>
                                                <td class="tc">ADC4</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">00101</td>
                                                <td class="tc">ADC5</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">00110</td>
                                                <td class="tc">ADC6</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">00111</td>
                                                <td class="tc">ADC7</td>
                                            </tr>
                                        </table>
                                        <br><br><br><br><br><br>

                                        <p>
                                            Сигнал в АЦП подается через мультиплексор, с одного из восьми входов, который
                                            выбирается битами MUX3…MUX0 регистра ADMUX. Кроме того, существует
                                            несколько служебных комбинаций битов MUX, использующихся для калибровки.
                                            Например, 11110 подключает к АЦП внутренний источник опорного напряжения
                                            на 1,22В. А если записать в MUX4..0 все единицы, то вход АЦП будет заземлён,
                                            что позволяет выявить шумы и помехи.
                                        </p>

                                        <p>
                                            У старших AVR семейства Mega (8535, 16, 32, 128, 256) есть возможность включить АЦП в режиме дифференциального входа,
                                            т.е. имеются 8 входных каналов, 7 дифференциальных входных каналов и 2 дифференциальных входных канала с выборочным коэффициентом усиления
                                            10 и 200. Они выбираются также битами MUX4…MUX0. При этом на два входа приходят разные напряжения, которые вычитаются друг из друга,
                                            и кроме того, ещё могут умножаться на коэффициент усиления. Это может быть полезно для замера перекоса напряжения измерительного моста.
                                            У тензомоста, к примеру, при входном напряжении 5В выходные сигналы будут различаться между собой всего лишь на 30мВ!
                                            При использовании дифференциального входа и подстройке нужного коэффициента усиления работа с таким датчиком становится возможной.
                                        </p>

                                        <p><b>Регистр ADCSRA</b> (Status and Control Register ADC). </p>

                                        <div align="center">
                                            <img src="images/096.png" title="Регистр ADCSRA"><br>
                                            Рис. Х. Регистр ADCSRA
                                        </div>
                                        <br>

                                        <p>
                                            <i>Бит 7 - ADEN: ADC Enable</i> – "1" / "0" – включение/выключение схемы ЦАП.
                                        </p>

                                        <p>
                                            <i>Бит 6 – ADSC: ADC Start Conversion</i> – "1" – Запуск аналогово-цифрового
                                            преобразования.
                                        </p>

                                        <p>
                                            <i>Бит 5 – ADATE: ADC Auto Trigger Enable</i> – Автозапуск преобразования по
                                            внешним сигналам.
                                        </p>

                                        <p>
                                            <i>Бит 4 – ADIF: ADC Interrupt Flag</i> – "1" – Преобразование завершилось.
                                            Регистры данных ADCH:ADCL обновились.
                                        </p>

                                        <p>
                                            <i>Бит 3 – ADIE: ADC Interrupt Enable</i> – Разрешение прерывания по флагу
                                            ADIF.
                                        </p>

                                        <p>
                                            <i>Биты 2:0 – ADPS2:0: ADC Prescaler Select Bits</i> – Коэффициент деления
                                            частоты между XTAL и тактовым входом АЦП.
                                        </p>

                                        <p>
                                            <b>Запуск аналогово-цифрового преобразования.</b> Обычно аналогово-цифровое
                                            преобразование запускается в микроконтроллере установкой в "1" бита
                                            ADSC (ADC Start Conversion).
                                        </p>

                                        <p>
                                            Помимо данного бита в МК AVR существует возможность запустить преобразование внешними сигналами.
                                            Для этого используется бит ADATE. Если он установлен в “1”,
                                            можно выбрать внешний источник запуска преобразования битами ADTS2:0.
                                        </p>

                                        <p>
                                            <b>Время аналогово-цифрового преобразования.</b> Как видно из следующего рисунка, битами
                                            ADPS2:0 можно выбирать коэффициент деления частоты на тактовом входе АЦП. Тем самым регулируется
                                            время аналогово-цифрового преобразования. Здесь CK – это тактовая частота микроконтроллера. Заметим, что мультиплексор имеет 7 входов, комбинация ADPS2:0 = 000 зарезервирована.
                                            АЦП МК AVR должен иметь тактовую частоту не более 200 кГц, в противном случае снижается точность.
                                        </p>

										<div align="center" style="float: left; margin: 10px 20px">
                                            <img src="images/097.png"><br>
                                        </div>

                                        <table border=1 cellpadding="1" cellspacing="1" align="center">
                                            <tr align=center bgcolor="#D1D6E9">
                                                <td class="tcb">ADPS2</td>
                                                <td class="tcb">ADPS1</td>
                                                <td class="tcb">ADPS0</td>
                                                <td class="tcb">Частота АЦП</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">0</td>
                                                <td class="tc">0</td>
                                                <td class="tc">0</td>
                                                <td class="tc">Зарезервировано</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">0</td>
                                                <td class="tc">0</td>
                                                <td class="tc">1</td>
                                                <td class="tc">CLK/2</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">0</td>
                                                <td class="tc">1</td>
                                                <td class="tc">0</td>
                                                <td class="tc">CLK/4</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">0</td>
                                                <td class="tc">1</td>
                                                <td class="tc">1</td>
                                                <td class="tc">CLK/8</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">1</td>
                                                <td class="tc">0</td>
                                                <td class="tc">0</td>
                                                <td class="tc">CLK/16</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">1</td>
                                                <td class="tc">0</td>
                                                <td class="tc">1</td>
                                                <td class="tc">CLK/32</td>
                                            </tr>
                                            <tr bgcolor="#EAEAEA">
                                                <td class="tc">1</td>
                                                <td class="tc">1</td>
                                                <td class="tc">0</td>
                                                <td class="tc">CLK/64</td>
                                            </tr>
                                            <tr bgcolor="#DCDCDC">
                                                <td class="tc">1</td>
                                                <td class="tc">1</td>
                                                <td class="tc">1</td>
                                                <td class="tc">CLK/128</td>
                                            </tr>
                                        </table>
                                        <br>

                                        <p>
                                            Например, FCLK = 16 МГц. Найти тактовую частоту для ADPS2:0 = 111 (десятичное 7).
                                            Строка таблицы CLK/128 → 16MHz/128 = 125 kHz < 200 kHz, т.е.
                                            меньше максимально возможной, поэтому удовлетворяет условию.
                                        </p>

                                        <p>
                                            При преобразовании синусоиды, согласно теоремы Котельникова,
                                            она должна иметь частоту не более 31 кГц.
                                            Поэтому звуковой сигнал в диапазоне слышимости оцифровать можно с достаточным качеством.
                                        </p>

                                        <p>
                                            <b>Время выборки и хранения (Sample-and-hold time) в АЦП.</b> Следует учесть, что время преобразования будет
                                            больше за счёт времени выборки данных. После того, как выбран определённый входной канал, некоторое время уходит
                                            на зарядку конденсатора выборки и хранения. Первое преобразование, при котором инициализируется аналоговая часть схемы, занимает максимум времени: 25 тактов частоты на входе АЦП. Каждое последующее преобразование, – 13 тактов. Если время преобразования несущественно, лучше выбрать ADPS2:0 = 111,
                                            чтобы получить максимальную точность. Тогда время преобразования t = 13*0,008 ms = 0,104 ms.
                                        </p>



                                        <p>Алгоритм программного опроса АЦП имеет вид:</p>

                                        <Ol>
                                            <li>Аналоговый вход (PortС) МК установить в режим входа.</li>
                                            <li>
                                                Включить АЦП (бит ADEN), поскольку после подачи питания он выключен.
                                            </li>
                                            <li>Установить скорость преобразования (биты ADPS2:0).</li>
                                            <li>
                                                Выбрать опорное напряжение (биты REFS1:REFS0 регистра ADMUX) и входные
                                                каналы ADC (биты MUX4: MUX0 регистра ADMUX).
                                            </li>
                                            <li>
                                                Дать сигнал “Start conversion” записью "1" в бит ADSC регистра ADCSRA.
                                            </li>
                                            <li>
                                                Ждать окончания преобразования, опрашивая флаг ADIF в регистре ADCSRA.
                                            </li>
                                            <li>
                                                Когда флаг ADIF := 1, прочитать сначала ADCL, а затем ADCH, иначе
                                                результат будет неверным.
                                            </li>
                                            <li>
                                                Если необходимо снова прочитать выбранный канал, вернуться к шагу 5.
                                            </li>
                                            <li>Если необходимо выбрать новый канал, вернуться к шагу 4.</li>
                                        </Ol>

                                        <p id="primer1">Рассмотрим этот алгоритм на примере следующей схемы:</p>

                                        <div align="center">
                                            <img src="images/098.png" title="Тестовая схема"><br>
                                            Рис. Х. Тестовая схема (<a href="..\Практика\projects\3_5_Primer.pdsprj">Скачать модель </a>)</p>
                                        </div>
                                        <br>

                                        <div align="center">
                                            <table>
                                                <tr>
														<td>
													
										<p>
                                            Здесь движок потенциометра позволяет изменять напряжение на входе ADC0 от 0 до Vcc.
                                            Результат измерения выведем на линейку светодиодов через порты B и D. Программный опрос флага готовности данных АЦП будет иметь вид:
                                        </p>

                                        <table width="100%" cellspacing="0" cellpadding="4" border="0">
                                            <tr>
                                                <td width="370">
                                                    <pre><code>.include "m328pdef.inc"
      ldi R16,0xFF
      out DDRB,R16        ;Порт В как выход
      out DDRD,R16        ;Порт D как выход
      ldi R16,0b00000000
      out DDRC,r16        ;Port C - вход для АЦП
;           7    6     5     4     3     2     1     0
;ADCSRA = ADEN ADSC  ADATE ADIF  ADIE  ADPS2 ADPS1 ADPS0
      ldi r16,0b10000111  ;разрешить АЦП-прерывание и CLK/128
      sts ADCSRA,r16      ;старт преобразования

;          7     6     5     4     3     2     1     0
;ADMUX = REFS1 REFS0 ADLAR  MUX4  MUX3  MUX2  MUX1  MUX0
      ldi r16,0b00000000  ;опорное - напряжение питания,
      sts ADMUX,r16       ;результат выравнивается вправо,
                          ;0-й канал АЦП
READ_ADC:
      lds r16,ADCSRA
      ori r16,0b01000000
      sts ADCSRA,R16      ;запуск преобразования
      KEEP_POLING:	  ;сидим здесь в ожидании конца преобразования

      lds r16,ADCSRA
      mov r18,r16
      andi r18,0b00010000
      cpi r18,0b00010000  ;преобразование завершено?
      brne KEEP_POLING

      lds r17, ADCSRA
      ldi r20, 0b00001000
      eor r17,r20
      sts ADCSRA,r17      ;пишем 1 для очистки флага ADIF

      lds R16,ADCL        ;читаем результат начиная с ADCL
      out PORTD,R16	  ;выводим младшую часть результата в PORTD
      lds R16,ADCH        ;заканчиваем читать результат в ADCH после ADCL
      out PORTB,R16	  ;выводим старшую часть результата в PORTB
      rjmp READ_ADC



</code></pre>
                                                </td>
                                                <td></td>
                                            </tr>
                                        </table>
													
														</td>
														
														<td>
														&nbsp;&nbsp;&nbsp;
														<td>
														
														<td>
														
										<p>
                                            Чтобы не загружать процессор опросом флага, целесообразно использовать прерывание по готовности данных преобразования (флаг ADIF).
                                            Для этого нужно разрешить локально прерывание ADIE = 1 (ADC Interrupt Enable).
                                            По окончании преобразования флаг ADIF := 1; и если ADIE = 1,
                                            то процессор перейдёт по вектору $002A, а оттуда – на подпрограмму обслуживания прерывания.
                                        </p>

                                        <table width="100%" cellspacing="0" cellpadding="4" border="0">
                                            <tr>
                                                <td width="370">
                                                    <pre><code>.include "m328pdef.inc"
.cseg
.org $0000 rjmp Reset     ;Reset
.org $002A rjmp ADC_Int   ;Преобразование в АЦП выполнено
.org INT_VECTORS_SIZE     ;Конец таблицы прерываний

Reset:ldi r16,Low(RAMEND) ;Старт программы
      out SPL,r16         ;Обязательная инициализация стека
      ldi r16,High(RAMEND);Указатель стека устанавливается
      out SPH,r16         ;на конец ОЗУ
      ldi r16,0xFF
      out DDRB,r16        ;Port B - выход
      out DDRD,r16        ;Port D - выход
      ldi r16,0
      out DDRC,r16        ;Port C - вход для АЦП
      sei                 ;Разрешаем прерывания глобально
;          7     6     5     4     3     2     1     0
;ADMUX = REFS1 REFS0 ADLAR  MUX4  MUX3  MUX2  MUX1  MUX0
      ldi r16,0x00        ;опорное - напряжение питания,
      sts ADMUX,r16       ;результат выравнивается вправо,
                          ;0-й канал АЦП
;           7    6     5     4     3     2     1     0
;ADCSRA = ADEN ADSC  ADATE ADIF  ADIE  ADPS2 ADPS1 ADPS0
      ldi r16,0b11001111  ;разрешить АЦП-прерывание и CLK/128
      sts ADCSRA,r16      ;старт преобразования

main: rjmp main           ;бесконечный цикл

ADC_Int:
      lds r16,ADCL        ;сначала читаем ADCL
      out PORTD,r16	  ;выводим старший байт в PORTD
      lds r16,ADCH	  ;затем читаем ADCH после ADCL
      out PORTB,r16	  ;выводим младший байт в PORTB
      lds r16,ADCSRA
      sbr r16,(1 << ADSC)
      sts ADCSRA,r16      ;запуск преобразования снова
      reti
 </code></pre>
                                                </td>
                                                <td></td>
                                            </tr>
                                        </table>
										<br>
														
														</td>
                                                </tr>
                                            </table>
                                        </div>


                                        <br><br>
                                        <a name="8"></a>
                                        <table border=0 cellpadding=0 cellspacing=0 width=97% bgcolor=#ABB3D5>
                                            <tr>
                                                <td bgcolor=#000000 colspan="2">
                                                    <img src=../Оболочка/images/raspor.gif
                                                         height="1">
                                                </td>
                                            </tr>
                                            <tr>
                                                <td width="30"></td>
                                                <td valign=center>
                                                    <span class=h>Программная реализация алгоритмов управления</span>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td bgcolor=#000000 width="25" colspan="2">
                                                    <img src=../Оболочка/images/raspor.gif height="1">
                                                </td>
                                            </tr>
                                        </table>
                                        <br><br>

                                        <a name="8.1"></a>
                                            <p class="h3">8.1 Программная реализация функций счёта и временной задержки</p>

                                            <p>
                                                Программное управление осуществляется в функции времени и заключается
                                                в формировании и выдаче управляющих воздействий в соответствии с заранее
                                                известной таблицей либо циклограммой.
                                            </p>

                                            <p>
                                                Для реализации программного управления необходимо представить
                                                исходную информацию в виде массива и организовать вывод его элементов через
                                                заданные промежутки времени. Отсчёт промежутков времени можно производить как при помощи
                                                аппаратных средств (таймер), так и программными средствами с помощью программ-задержек.
                                                Они представляют собой группы циклически повторяющихся команд, время выполнения каждой
                                                из которых можно оценить по числу тактов процессора. При этом возникает необходимость
                                                выполнения определенных действий заданное количество раз. Для этого используются
                                                программные счётчики, которые реализуются двумя способами:
                                            </p>

                                            <Center>
                                                <Table Border=0 valign=top>
                                                    <Tr>
                                                        <Td><P>1. Путем инкремента содержимого<Br> регистра или ячейки памяти:</P></Td>
                                                        <Td>&nbsp;&nbsp;</Td>
                                                        <Td><P>2. Путем декремента содержимого<Br> регистра или ячейки памяти:</P></Td>
                                                    </Tr>
                                                    <tr>
                                                        <td valign=top>
                                                            <table Border=0 align=center>
                                                                <Tr>
                                                                    <Td>
                                                                        <code>&nbsp;</code>
                                                                    </Td>
                                                                    <Td>
                                                                        <code><b>clr</b>&nbsp;&nbsp;r22 ;r22=0</code>
                                                                    </Td>
                                                                </Tr>
                                                                <Tr>
                                                                    <Td>
                                                                        <code>Loop:</code>
                                                                    </Td>
                                                                    <Td>
                                                                        <Table Border=0 CellPadding=0 CellSpacing=0>
                                                                            <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                            <Tr>
                                                                                <Td Bgcolor=#000000><Img Src=images/115.gif></Td>
                                                                                <Td><code>&nbsp;&nbsp;Тело цикла&nbsp;&nbsp;</code></Td>
                                                                                <Td Bgcolor=#000000>
                                                                                    <Img Src=images/115.gif>
                                                                            </Tr>
                                                                            <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                        </Table>
                                                                    </Td>
                                                                </Tr>
                                                                <Tr>
                                                                    <Td rowspan=4 valign=top>
                                                                        <P>
                                                                            <Img Src=images/110.gif><br>
                                                                            <Img Src=images/111.gif><br><Img Src=images/111.gif><br>
                                                                            <Img Src=images/111.gif><br><Img Src=images/111.gif><br>
                                                                            <Img Src=images/111.gif><br><Img Src=images/111.gif><br>
                                                                            <Img Src=images/114.gif><br>
                                                                        </P>
                                                                    </Td>
                                                                    <Td>
                                                                        <code><b>inc</b>&nbsp;&nbsp;r22</code>
                                                                    </Td>
                                                                </Tr>
                                                                <Tr>
                                                                    <Td>
                                                                        <code><b>cpi</b>&nbsp;&nbsp;r22, $1E</code>
                                                                    </Td>
                                                                </Tr>
                                                                <Tr>
                                                                    <Td>
                                                                        <code><b>brne</b> Loop</code>
                                                                    </Td>
                                                                </Tr>
                                                            </table>
                                                        </td>
                                                        <td>
                                                            &nbsp;
                                                        </td>
                                                        <td valign=top>
                                                            <table Border=0 align=center>
                                                                <Tr>
                                                                    <Td>
                                                                        <code>&nbsp;</code>
                                                                    </Td>
                                                                    <Td>
                                                                        <code><b>di</b> &nbsp;r22, $1E</code>
                                                                    </Td>
                                                                </Tr>
                                                                <Tr>
                                                                    <Td>
                                                                        <code>Loop:</code>
                                                                    </Td>
                                                                    <Td>
                                                                        <Table Border=0 CellPadding=0 CellSpacing=0>
                                                                            <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                            <Tr>
                                                                                <Td Bgcolor=#000000><Img Src=images/115.gif></Td>
                                                                                <Td><code>&nbsp;&nbsp;Тело цикла&nbsp;&nbsp;</code></Td>
                                                                                <Td Bgcolor=#000000><Img Src=images/115.gif>
                                                                            </Tr>
                                                                            <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                        </Table>
                                                                    </Td>
                                                                </Tr>
                                                                <Tr>
                                                                    <Td rowspan=4 valign=top>
                                                                        <P>
                                                                            <Img Src=images/110.gif><br><Img Src=images/111.gif><br>
                                                                            <Img Src=images/111.gif><br><Img Src=images/114.gif>
                                                                        </P>
                                                                    </Td>
                                                                    <Td>
                                                                        <code><b>dec</b> &nbsp;r22</code>
                                                                    </Td>
                                                                </Tr>
                                                                <Tr>
                                                                    <Td>
                                                                        <code><b>brne</b> Loop</code>
                                                                    </Td>
                                                                </Tr>
                                                            </table>
                                                        </td>
                                                    </tr>
                                                </Table>

                                                <p>
                                                    В этих примерах <i>тело цикла выполняется 30 раз</i> и позволяют реализовать число повторов от 1 до 256.
                                                    Очевидно, что второй способ более удобен, так как он на одну команду меньше, и если начальное значение <i>R22 = 0</i>,
                                                    то цикл повторится 256 раз. При необходимости в числе повторов более 255 можно использовать вложенные счётчики.
                                                    Программный <i>счётчик с количеством повторений 1200</i> может выглядеть следующим образом:
                                                </p><br>

                                                <table Border=0 align=center cellpadding=0 cellspacing=0>
                                                    <Tr>
                                                        <Td>
                                                            <code>&nbsp;</code>
                                                        </Td>
                                                        <Td>
                                                            <code>&nbsp;</code>
                                                        </Td>
                                                        <Td>
                                                            <code><b>ldi</b></code>
                                                        </Td>
                                                        <Td>
                                                            <code>r22, $1E</code>
                                                        </Td>
                                                        <Td>
                                                            <code>;счетчик 30 циклов</code>
                                                        </Td>
                                                    </Tr>
                                                    <Tr>
                                                        <Td rowspan=5 valign=top align=right>
                                                            <P>
                                                                <Img Src=images/113.gif><br>
                                                                <Img Src=images/111.gif><br><Img Src=images/111.gif><br><Img Src=images/111.gif><br>
                                                                <Img Src=images/111.gif><br><Img Src=images/111.gif><br><Img Src=images/111.gif><br>
                                                                <Img Src=images/111.gif><br><Img Src=images/111.gif><br><Img Src=images/111.gif><br>
                                                                <Img Src=images/111.gif><br><Img Src=images/111.gif><br><Img Src=images/111.gif><br>
                                                                <Img Src=images/111.gif><br><Img Src=images/111.gif><br><Img Src=images/111.gif><br>
                                                            </P>
                                                        </Td>
                                                        <Td>
                                                            <code>M0:</code>
                                                        </Td>
                                                        <Td>
                                                            <code><b>ldi</b></code>
                                                        </Td>
                                                        <Td>
                                                            <code>r23, $28</code>
                                                        </Td>
                                                        <Td rowspan=6 valign=top>
                                                            <code>;счетчик 40 циклов</code>
                                                        </Td>
                                                    </Tr>
                                                    <Tr>
                                                        <Td valign=top>
                                                            <code>M1:</code>
                                                        </Td>
                                                        <Td colspan=2>
                                                            <Table Border=0 CellPadding=0 CellSpacing=0>
                                                                <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                <Tr>
                                                                    <Td Bgcolor=#000000><Img Src=images/115.gif></Td>
                                                                    <Td><code>&nbsp;&nbsp;Тело цикла&nbsp;&nbsp;</code></Td>
                                                                    <Td Bgcolor=#000000><Img Src=images/115.gif>
                                                                </Tr>
                                                                <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                            </Table>
                                                        </Td>
                                                    </Tr>
                                                    <Tr>
                                                        <td rowspan=3 valign=top>
                                                            <P>
                                                                <Img Src=images/110.gif><br><Img Src=images/111.gif><br>
                                                                <Img Src=images/112.gif>
                                                            </P>
                                                        </td>
                                                        <Td>
                                                            <code><b>dec</b></code>
                                                        </Td>
                                                        <Td>
                                                            <code>r23</code>
                                                        </Td>
                                                    </Tr>
                                                    <Tr>
                                                        <Td>
                                                            <code><b>brne</b></code>
                                                        </Td>
                                                        <Td>
                                                            <code>M1</code>
                                                        </Td>
                                                    </Tr>
                                                    <Tr>
                                                        <Td>
                                                            <code><b>dec</b></code>
                                                        </Td>
                                                        <Td>
                                                            <code>r22</code>
                                                        </Td>
                                                    </Tr>
                                                    <Tr>
                                                        <Td colspan=2 valign=top>
                                                            <Img Src=images/114.gif><br>
                                                        </Td>
                                                        <Td>
                                                            <code><b>brne</b></code>
                                                        </Td>
                                                        <Td>
                                                            <code>M0</code>
                                                        </Td>
                                                    </Tr>
                                                </table><br>


                                                <p>
                                                    Программные счётчики позволяют задержать выполнение программы на заданное время.
                                                    Идея состоит в том, чтобы загрузить контроллер бессмысленной работой, чтобы выполнить определённое число тактов.
                                                    А так как время выполнения команд строго привязано к тактовой частоте, то зная её легко вычислить время задержки.
                                                    При F<sub>CLK</sub> = 16 МГц, T<sub>CLK</sub> = 1/16000000 = 0,0000000625 сек = 0,0625 мкс.
                                                    Так как в МК AVR большинство команд выполняются за один такт, то время выполнения одной команды составит 0,0625 мкс.
                                                </p>
                                                <p>
                                                    Таблица соответствия между командами и количеством тактов приводится в документации на микроконтроллер.
                                                    Одна цифра, например 2, означает, что команда выполняется за 2 такта. Обозначение 1/2 или 1/2/3 указывает, для примера 1/2,
                                                    что команда может выполниться за 1 или 2 такта в зависимости от условия выполнения команды. Например,
                                                    команда <code style="color: #005599">breq</code> выполнится за 1 такт, если нет ветвления по условию, и за 2 такта, если произойдет условный переход.
                                                </p>

                                                <p>
                                                    Для больших задержек используются вложенные циклы с несколькими счётчиками.
                                                    Тогда на трёх вложенных циклах можно получить около 1 секунды, а на четырёх – уже 268 секунд.
                                                    Однако более оптимальное решение, – вычитание многобайтного числа с переносом.
                                                </p>

                                                <table width="100%" cellspacing="0" cellpadding="4" border="0">
                                                    <tr>
                                                        <td width="370">
                                                            <pre><code>
      ldi r16,LowByte		; Загрузка трёх байт
      ldi r17,MidleByte		; задержки
      ldi r18,HighByte
Loop: subi r16,1   		; Вычитание 1
      sbci r17,0		; Вычитание только С
      sbci r18,0		; Вычитание только С
      brcc Loop 		; Если нет переноса - переход


</code></pre>
                                                        </td>
                                                        <td></td>
                                                    </tr>
                                                </table>

                                                <p>
                                                    В результате, вначале из первого числа вычитается 1, а перенос возникает только когда заканчивается очередной байт.
                                                    В результате из R16 вычитается на каждой итерации, из R17 на каждой 256 итерации, а из R18 на каждой 65535 итерации.
                                                    Всего на трёх таких регистрах можно организовать задержку на 256*256*256 = 16’777’216 тактов, что при тактовой частоте 16МГц
                                                    соответствует задержке около 1,049сек. Аналогично, при использовании большего количества регистров можно получить и большую задержку,
                                                    длительность которой будет точней, т.к. в отличии от вложенных циклов, команда brcc всегда будет выполняться за 2 такта и лишь в
                                                    последнем случае – за один.
                                                </p>

                                                <p>
                                                    Однако для реализации большей точности и длительных задержек чаще применяют не программные, а аппаратные средства – таймеры.
                                                </p><br>

                                                <a name="8.2"></a>
                                                    <p class="h3">8.2 Программная генерация импульсов и функций времени</p>

                                                    <p>
                                                        При реализации систем управления часто требуется формирование импульсов, которые могут быть трёх различных типов:
                                                        1) без учёта длительности (рис. 42, а);
                                                        2) с заданной длительностью импульсов и длительностью пауз (рис. 42, б);
                                                        3) периодические (рис. 42, в).
                                                        Импульсы заданной длительности t<sub>2</sub> и периода t<sub>1</sub> (рис. 43, а) можно сформировать при помощи временной задержки и команд вывода out,
                                                        выдавая их на одну из линий порта.

                                                    </p>

                                                    <div align="center"><img src="images/108.gif"></div>

                                                    <p>
                                                        Импульсы заданной длительности t<sub>2</sub> и периода t<sub>1</sub> (рис. 43, а)
                                                        можно сформировать при помощи временной задержки и команд вывода <code style="color: #005599">out</code>, выдавая их на одну из линий порта.
                                                    </p>

                                                    <Center>
                                                        <Table Border=0 valign=top>
                                                            <tr>
                                                                <td valign=top>
                                                                    <table Border=0 align=center>
                                                                        <Tr>
                                                                            <Td>
                                                                                <code>Loop:</code>
                                                                            </Td>
                                                                            <Td>
                                                                                <code><b>ldi</b> r16, 0b00000010&nbsp; ;вкл. линии 1</code>
                                                                            </Td>
                                                                        </Tr>
                                                                        <Tr>
                                                                            <Td>
                                                                                <code>&nbsp;</code>
                                                                            </Td>
                                                                            <Td>
                                                                                <code><b>clr</b>&nbsp;out PORTD, r16</code>
                                                                            </Td>
                                                                        </Tr>

                                                                        <Tr>
                                                                            <Td>
                                                                                <code>&nbsp;</code>
                                                                            </Td>
                                                                            <Td>
                                                                                <Table Border=0 CellPadding=0 CellSpacing=0>
                                                                                    <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                                    <Tr>
                                                                                        <Td Bgcolor=#000000><Img Src=images/115.gif></Td>
                                                                                        <Td><code>&nbsp;&nbsp;Задержка на τ1&nbsp;&nbsp;</code></Td>
                                                                                        <Td Bgcolor=#000000>
                                                                                            <Img Src=images/115.gif>
                                                                                    </Tr>
                                                                                    <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                                </Table>
                                                                            </Td>
                                                                        </Tr>

                                                                        <Tr>
                                                                            <Td rowspan=4 valign=top>
                                                                            </Td>
                                                                            <Td>
                                                                                <code><b>ldi</b>&nbsp;r16, 0x00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;выкл. линии 1</code>
                                                                            </Td>
                                                                        </Tr>
                                                                        <Tr>
                                                                            <Td>
                                                                                <code><b>out</b>&nbsp;PORTD, r16</code>
                                                                            </Td>
                                                                        </Tr>

                                                                        <Tr>
                                                                            <Td>
                                                                                <Table Border=0 CellPadding=0 CellSpacing=0>
                                                                                    <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                                    <Tr>
                                                                                        <Td Bgcolor=#000000><Img Src=images/115.gif></Td>
                                                                                        <Td><code>&nbsp;&nbsp;Задержка на τ2&nbsp;&nbsp;</code></Td>
                                                                                        <Td Bgcolor=#000000>
                                                                                            <Img Src=images/115.gif>
                                                                                    </Tr>
                                                                                    <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                                </Table>
                                                                            </Td>
                                                                        </Tr>

                                                                        <Tr>
                                                                            <Td>
                                                                                <code><b>rjmp</b> M0</code>
                                                                            </Td>
                                                                        </Tr>
                                                                    </table>
                                                                </td>
                                                                <td>
                                                                    &nbsp;
                                                                </td>

                                                            </tr>
                                                        </Table><br>


<p>Недостатки этой программы очевидны: она зациклена, а при выводе по команде <code style="color: #005599">out</code> затрагивается не только заданная линия порта, но и другие линии, которые могут быть
    задействованы для других целей. Чтобы этого избежать, требуется иметь копию данных в памяти
    и изменять только один бит. Эту программу можно упросить, если необходимо обеспечить одинаковую длительность импульсов и пауз (такой сигнал называется меандром): t<sub>1</sub> = t<sub>2</sub> = t:</p>

                                                        <Center>
                                                            <Table Border=0 valign=top>
                                                                <tr>
                                                                    <td valign=top>
                                                                        <table Border=0 align=center>
                                                                            <Tr>
                                                                                <Td>
                                                                                    <code>&nbsp;</code>
                                                                                </Td>
                                                                                <Td>
                                                                                    <code><b>ldi</b> r16, 0b00000010</code>
                                                                                </Td>
                                                                            </Tr>
                                                                            <Tr>
                                                                                <Td>
                                                                                    <code>M0:</code>
                                                                                </Td>
                                                                                <Td>
                                                                                    <code><b>com</b>&nbsp;r16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;инверсия</code>
                                                                                </Td>
                                                                            </Tr>
                                                                            <Tr>
                                                                                <Td>
                                                                                    <code>&nbsp;</code>
                                                                                </Td>
                                                                                <Td>
                                                                                    <code><b>out</b> PORTD, r16</code>
                                                                                </Td>
                                                                            </Tr>
                                                                            <Tr>
                                                                                <Td>
                                                                                    <code>&nbsp;</code>
                                                                                </Td>
                                                                                <Td>
                                                                                    <Table Border=0 CellPadding=0 CellSpacing=0>
                                                                                        <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                                        <Tr>
                                                                                            <Td Bgcolor=#000000><Img Src=images/115.gif></Td>
                                                                                            <Td><code>&nbsp;&nbsp;Задержка на τ1&nbsp;&nbsp;</code></Td>
                                                                                            <Td Bgcolor=#000000>
                                                                                                <Img Src=images/115.gif>
                                                                                        </Tr>
                                                                                        <Tr><Td ColSpan=3 Bgcolor=#000000><Img Src=images/115.gif Height=1></Td></Tr>
                                                                                    </Table>
                                                                                </Td>
                                                                            </Tr>

                                                                            <Tr>
                                                                                <Td>
                                                                                    <code>&nbsp;</code>
                                                                                </Td>
                                                                                <Td>
                                                                                    <code><b>rjmp</b> M0</code>
                                                                                </Td>
                                                                            </Tr>
                                                                        </table>
                                                                    </td>
                                                                    <td>
                                                                        &nbsp;
                                                                    </td>
                                                                </tr>
                                                            </Table><br>


<p>Однако в этом случае ресурсы процессора задействованы полностью, поэтому более рационально использовать таймер.
При управлении техпроцессами часто требуется формирование функций времени, т.е. сигналов сложной, непрямоугольной формы (рис. 42, г).
Для их реализации используется ЦАП, подключаемый к порту вывода (рис. 44). Уровень напряжения на выходе ЦАП определяется кодом, формируемым на линиях порта.
При этом максимальный уровень сигнала соответствует коду FFh, а минимальный – 00h.
Форму функции времени удобно занести в массив U<sub>1</sub>,U<sub>2</sub>,U<sub>3</sub> и t<sub>1</sub>,t<sub>2</sub>,t<sub>3</sub>.
Таким образом, выдавая на линии порта определенные значения напряжения через заданные промежутки времени, можно получить сигнал практически любой формы.</p>

<div align="center"><img src="images/108_1.png"></div>

                                    </td>
                                </tr>
                            </table>
                            <br><br>




<a name="9"></a>
<table border=0 cellpadding=0 cellspacing=0 width=97% bgcolor=#ABB3D5>
    <tr>
        <td bgcolor=#000000 colspan="2">
            <img src=../Оболочка/images/raspor.gif
                 height="1">
        </td>
    </tr>
    <tr>
        <td width="30"></td>
        <td valign=center>
            <span class=h>Таймеры/счетчики</span>
        </td>
    </tr>
    <tr>
        <td bgcolor=#000000 width="25" colspan="2">
            <img src=../Оболочка/images/raspor.gif height="1">
        </td>
    </tr>
</table>
<br><br>

<p>
    Как отмечалось ранее для реализации большей точности и длительных задержек чаще применяют не программные,
    а аппаратные средства – таймеры-счётчики. Они позволяют считать входные импульсы и работают независимо
    от основного потока выполнения программы. Таймеры вырабатывают запросы прерываний, переключая МК на их
    обслуживание по событиям и освобождая его от необходимости периодического опроса состояния этих устройств.
    Таймеры используются для:
</p>

<ul>
    <li>точного отсчёта реального времени, формирования временных интервалов, измерения частоты и длительности импульсов;</li>
    <li>подсчёта внешних импульсов на выводах МК;</li>
    <li>формирования последовательности импульсов;</li>
    <li>ШИМ для генерации сигнала с программируемыми частотой и скважностью;</li>
    <li>тактирования приёмопередатчика UART;</li>
    <li>возможность работать в асинхронном режиме как часы реального времени.</li>
</ul>
					
<div align="center" style="float: left; margin: 10px 20px">
    <img src="images/116.png" title="Общая структура таймера-счётчика"><br>
    Рис. 1. Общая структура таймера-счётчика.
</div>

<p>
    Длительность периодов зависит от тактовой частоты МК, и от настроек таймера,
    однако значение времени с момента запуска имеет размерность не минут или секунд,
    а выражено в периодах тактовых циклов таймера (“тиках”).
</p>

<p>
    Основным элементом таймера-счётчика является счётный регистр TCNT (Timer-Counter) (рис. 1).
    На его вход поступают импульсы с мультиплексора. При переполнении счётчика аппаратно устанавливается флаг TOV, который
    сбрасывается программно. На входе счётчика – 2-входовый мультиплексор, который может переключать источник тактирования,
    – либо генератор тактовой частоты МК, либо внешние импульсы на специальном входе МК. Поэтому таймер может подсчитывать как временные интервалы,
    так и любые внешние события.
</p>

<p>
    Для определённости рассмотрим микроконтроллер ATmega328p. Он имеет три таймера: Timer0, Timer1 и Timer2 со своими независимыми
    счётными регистрами TCNT. В Timer0 и Timer2 TCNT0 и TCNT2 – 8-битные, в Timer1 TCNT1 – 16-битный. Каждый счётчик TCNT инкрементируется импульсами,
    поступающими на его вход. Кроме того, в него можно
    записать исходное значение. При переполнении счётчика каждого таймера устанавливается соответствующий флаг TOV.
    Частота выдачи TOV может регулироваться исходным значением.
</p>

<p>
    Каждый таймер AVR настраивается на обработку одного из трёх событий, по наступлению которых выставляются флаги состояния.
</p>

<p>
    <b>Переполнение</b> (Timer Overflow) таймера означает, что его счётчик досчитал до своего предельного значения
    (255 либо 65535, определяемого разрядностью регистра TCNT) и сбросился в 0 при следующем тактовом цикле.
    Событие переполнения установит флаг Timer Overflow (TOVx) в регистре Timer Interrupt Flag Register (TIFR).
</p>

<p>
    <b>Совпадение</b> (Compare Match). В случаях, когда недостаточно отслеживать переполнение таймера,
    может использоваться прерывание по совпадению счётчика с неким заданным значением.
    Регистр Output Compare Register (OCRx) может быть загружен значением [0..MaxVal]
    которое будет проверяться на совпадение со счётчиком при каждом тактовом цикле таймера.
    Когда таймер достигнет значения сравнения, будет установлен соответствующий флаг Output Compare Flag (OCFx)
    в регистре TIFR. Таймер может быть сконфигурирован для очистки регистра счётчика в 0 при событии совпадения.
</p>

<p>
    Связанные с функцией совпадения порты микроконтроллера могут быть сконфигурированы как выходы для автоматической установки,
    сброса и переключения при наступлении события совпадения. Эта функция удобна для генерации сигналов прямоугольной формы
    различных частот, а также для преобразования цифровых данных в аналоговый сигнал (режим PWM).
</p>

<p>Захват входа (Input Capture). МК AVR имеют входной порт, предназначенный для срабатывания от входных событий.
Изменение сигнала на этом входе вызовет копирование значения счётчика таймера в регистр захвата Input Capture Register (ICRx).
Одновременно с этим установится флаг Input Capture Flag (ICFx) в регистре TIFR. Функция захвата полезна для измерения длительности внешних импульсов.
</p>

<p>Рассмотрим структуру таймера 0 (рис. 2). Он является самым простым из имеющихся у ATmega328p и имеет следующие возможности:</p>

<ul>
    <li>Два независимых узла для проверки совпадения счётчика с заданной величиной, которые могут выдавать изменение выходного уровня – Output Compare Units (применяется для ШИМ).</li>
    <li>Выходные регистры сравнения (Output Compare Registers).</li>
    <li>Очистка таймера при событии совпадения (Compare Match), т.е. автоматическая перезагрузка таймера.</li>
    <li>Широтно-импульсный модулятор с точным, без скачков, изменением фазы выходных импульсов - Phase Correct Pulse Width Modulator (PWM).</li>
    <li>Регулируемый период ШИМ.</li>
    <li>Функция генератора частоты.</li>
    <li>3 независимых источника прерывания (TOV0, OCF0A и OCF0B).</li>
</ul>

<p>Timer0 в программе обычно применяют для формирования точных и коротких интервалов времени (управление событиями), генерации сигналов.</p>

<div align="center"><img src="images/117.png" title="Структура таймера-счётчика 0"><br>
Рис. 2. Структура таймера-счётчика 0.</div>

<p>Таймер-счётчик может тактироваться от внутренней тактовой частоты, которая может опционально делиться счётчиком-предделителем
    на 8, 64, 256 и 1024, либо от внешнего тактового сигнала, поданного на вывод T0. Блок логики управления определяет источник
    тактового сигнала и тактовый перепад, которые использует таймер-счётчик для счёта (инкремента или декремента своего значения
    с каждым таковым импульсом – биты WGM00..WGM02). Таймер-счётчик не активен, когда не выбран источник тактового сигнала.
    Мультиплексор выбирает нужное значение битами CS02:0 регистра TCCR0B (Timer/Counter Control Register). Детектор фронта сигнала
    позволяет выбрать событие, на которое будет реагировать таймер: переход 0 → 1, 1 → 0 или на любой из них.
</p>

<p>Как и любое периферийное устройство, таймер управляется рядом регистров. Для Timer0 – это:</p>

<ul>
    <li>TCNT0 – счётный регистр таймера/счётчика T0;</li>
    <li>OCR0A, OCR0B – регистры сравнения A и B;</li>
    <li>TCCR0A, TCCR0B – регистры управления A и B;</li>
    <li>TIMSK0 – регистр маски прерываний для таймера/счётчика T0;</li>
    <li>TIFR0 – регистр флагов прерываний для таймера/счётчика T0.</li>
</ul>

<p>
    <b>Регистр TCNT0</b> (Timer-CouNTer 0) 8-разрядный счётный регистр, который хранит текущее значение, до которого сейчас досчитал таймер.
    Каждый тактовый импульс увеличивает его значение на единицу. Диапазон счёта составляет от 0 до FFH.
</p>

<p>
    <b>Регистры сравнения OCR0A и OCR0B</b> (Output Compare Registers) – регистры двух независимых каналов сравнения.
    В них заносятся числа, с которыми на каждом тактовом импульсе сравнивается содержимое регистра TCNT0. Например,
    если в OCR0B записать 0х80, то когда TCNT0 досчитает до этого числа, будет вызвано прерывание либо изменится состояние вывода ОС0.
    Результат сравнения может использоваться для генерирования на выводах OC0A и OC0B сигнала ШИМ или изменяемой частоты. Также при возникновении
    события сравнения устанавливаются флаги OCF0A или OCF0B, которые могут использоваться для генерации запроса на прерывание Output Compare Flag.
</p>

<p>
    <b>Регистры TCCR0A и TCCR0B</b> (Timer-Counter Control Register), или регистры управления таймером, позволяют выбирать режим работы: таймер,
    либо формирователь ШИМ, а также желаемую частоту на входе счётчика.
</p>

<div align="center"><img src="images/118.png" title="TCCR0A"></div><br><br>

<div align="center"><img src="images/119.png" title="TCCR0B"></div><br>

<p><i>Биты WGM2:0 Waveform Generation Mode</i> – выбо режима работы:</p>

<ul>
  <li>Normal Mode (нормальный режим, счёт до переполнения);</li>
  <li>СТС (Clear Timer on Compare match) – очистить таймер по совпадению;</li>
  <li>Два типа широтно-импульсной модуляции (ШИМ, или PWM – Pulse-Width Modulation): Phase Correct PWM и Fast PWM.</li>
</ul>

<p>Режимы работы устанавливаются в соответствии со следующей таблицей:</p>

<table border=1 cellpadding="1" cellspacing="1" align="center">
  <tr align=center bgcolor="#D1D6E9">
    <td rowspan="2" class="tcb">Режим</td> <td colspan="3" class="tcb">WGM</td> <td rowspan="2" class="tcb">Описание</td> <td rowspan="2" class="tcb">TOP</td>
    <td rowspan="2" class="tcb">Update of OCRO at</td> <td rowspan="2" class="tcb">TOV0 Flag Set on</td>
  </tr>
  <tr align=center bgcolor="#D1D6E9">
    <td class="tcb">02</td> <td class="tcb">01</td> <td class="tcb">00</td>
  </tr>
  <tr bgcolor="#EAEAEA">
    <td class="tc">0</td> <td class="tc">0</td> <td class="tc">0</td> <td class="tc">0</td> <td class="tc">Normal</td> <td class="tc">0xFF</td> <td class="tc">Immediate</td> <td class="tc">0xFF</td>
  </tr>
  </tr>
  <tr bgcolor="#DCDCDC">
    <td class="tc">1</td> <td class="tc">0</td> <td class="tc">0</td> <td class="tc">1</td> <td class="tc">PWM, Phase Correct</td> <td class="tc">0xFF</td> <td class="tc">TOP</td> <td class="tc">0x00</td>
  </tr>
  <tr bgcolor="#EAEAEA">
    <td class="tc">2</td> <td class="tc">0</td> <td class="tc">1</td> <td class="tc">0</td> <td class="tc">CTC</td> <td class="tc">OCRA</td> <td class="tc">Immediate</td> <td class="tc">0xFF</td>
  </tr>
  <tr bgcolor="#DCDCDC">
    <td class="tc">3</td> <td class="tc">0</td> <td class="tc">1</td> <td class="tc">1</td> <td class="tc">Fast PWM</td> <td class="tc">0xFF</td> <td class="tc">0x00</td> <td class="tc">0xFF</td>
  </tr>
  <tr bgcolor="#EAEAEA">
    <td class="tc">4</td> <td class="tc">1</td> <td class="tc">0</td> <td class="tc">0</td> <td class="tc">-</td> <td class="tc">-</td> <td class="tc">-</td> <td class="tc">-</td>
  </tr>
  <tr bgcolor="#DCDCDC">
    <td class="tc">5</td> <td class="tc">1</td> <td class="tc">0</td> <td class="tc">1</td> <td class="tc">PWM, Phase Correct</td> <td class="tc">OCRA</td> <td class="tc">TOP</td> <td class="tc">0x00</td>
  </tr>
  <tr bgcolor="#EAEAEA">
    <td class="tc">6</td> <td class="tc">1</td> <td class="tc">1</td> <td class="tc">0</td> <td class="tc">-</td> <td class="tc">-</td> <td class="tc">-</td> <td class="tc">-</td>
  </tr>
  <tr bgcolor="#DCDCDC">
    <td class="tc">7</td> <td class="tc">1</td> <td class="tc">1</td> <td class="tc">1</td> <td class="tc">Fast PWM</td> <td class="tc">OCRA</td> <td class="tc">0x00</td> <td class="tc">TOP</td>
  </tr>
</table>

<p>Если событие совпадения возникает в режиме CTC, то таймер сбрасывается. В режиме Normal таймер продолжает считать до максимума.</p>

<p><i>Биты CS02:CS00 (Timer0 Clock Source)</i> – настройка предделителя.</p>

<table border=1 cellpadding="1" cellspacing="1" align="center">
  <tr align=center bgcolor="#D1D6E9">
    <td class="tcb">CS02</td> <td class="tcb">CS01</td> <td class="tcb">CS00</td> <td class="tcb">Расшифровка</td>
  </tr>
  <tr bgcolor="#EAEAEA">
    <td class="tc">0</td> <td class="tc">0</td> <td class="tc">0</td> <td class="tc">Не выбран источник частоты (Таймер остановлен)</td>
  </tr>
  <tr bgcolor="#DCDCDC">
      <td class="tc">0</td> <td class="tc">0</td> <td class="tc">1</td> <td class="tc">Clk<sub>I/O</sub> (Нет предделителя)</td>
  </tr>
  <tr bgcolor="#EAEAEA">
      <td class="tc">0</td> <td class="tc">1</td> <td class="tc">0</td> <td class="tc">Clk<sub>I/O</sub>/8 (От предделителя)</td>
  </tr>
  <tr bgcolor="#DCDCDC">
      <td class="tc">0</td> <td class="tc">1</td> <td class="tc">1</td> <td class="tc">Clk<sub>I/O</sub> /64 (От предделителя)</td>
  </tr>
  <tr bgcolor="#EAEAEA">
      <td class="tc">1</td> <td class="tc">0</td> <td class="tc">0</td> <td class="tc">Clk<sub>I/O</sub> /256 (От предделителя)</td>
  </tr>
  <tr bgcolor="#DCDCDC">
      <td class="tc">1</td> <td class="tc">0</td> <td class="tc">1</td> <td class="tc">Clk<sub>I/O</sub> /1024 (От предделителя)</td>
  </tr>
  <tr bgcolor="#EAEAEA">
      <td class="tc">1</td> <td class="tc">1</td> <td class="tc">0</td> <td class="tc">Внешний источник частоы на входе T0. Частота по спаду импульса.</td>
  </tr>
  <tr bgcolor="#DCDCDC">
      <td class="tc">1</td> <td class="tc">1</td> <td class="tc">1</td> <td class="tc">Внешний источник частоы на входе T0. Частота по фронту импульса.</td>
  </tr>
</table>

 <p>
     <i>Биты COM0 (A0, A1, B0, B1) Compare Output Mode</i> – задают поведение выводов МК Compare Output OC0A, OC0B (выход события совпадения).
     Связанные с функцией совпадения порты микроконтроллера могут быть сконфигурированы как выходы для автоматической установки,
     сброса и переключения при наступлении события совпадения. Таймер может переключать состояние выводов OC0А,
     OC0B делая это попеременно с заданным периодом. Эта функция удобна для генерации сигналов прямоугольной формы различной частоты,
     а также для преобразования цифровых данных в аналоговый сигнал (режим PWM).
 </p>

 <p>
     <i>Биты FOC0B, FOC0A (Force Output Compare)</i> – применяются при генерации импульсной последовательности.
     Программная запись “1” в этот бит заставляет генератор импульсов вести себя так, будто произошло событие совпадения (Output Compare match).
 </p>

 <p>
     <b>Регистр TIFR0</b> (Interrupt Flag Register) – регистр флагов запросов на прерывание TOV и OCFA, OCFB,
     которые устанавливаются по событиям переполнения и совпадения.
 </p>

 <div align="center"><img src="images/120.png" title="TIFR0"><br></div>

 <p>
     <i>Бит 0 – TOV: Timer/Counter0 Overflow Flag</i> (запрос на прерывание по событию переполнения от таймера 0) “0” / “1” – Таймер0 не переполнялся /
     Таймер0 переполнился (TCNT0: 255 → 0). При этом если установлены флаги разрешения прерываний I-bit в регистре состояний SREG и TOIE0
     (Timer/Counter0 Overflow Interrupt Enable), то произойдёт прерывание по вектору $20.
 </p>

 <p>
     <i>Биты 1, 2 – OCFA, B: Output Compare Flag</i> (запросы на прерывание по событию совпадения от таймера 0) “0” / “1” – события совпадения не происходило /
     произошло совпадение: TCNT0 := регистру OCR0A или OCR0B. При этом если установлены флаги разрешения прерываний I-bit в регистре состояний SREG и OCIE0
     (Timer/Counter0 Compare Match Interrupt Enable), то произойдет прерывание по вектору $1C или $1E соответственно.
 </p>

 <p>
     Чтобы программно сбросить флаг, например, TOV, необходимо записать в него “1”. Это справедливо в отношении всех флагов микроконтроллеров AVR.
     Например, для очистки флага TOV нужно:
 </p>

<table width="100%" cellspacing="0" cellpadding="4" border="0">
 <tr><td width="490"><pre><Code>    ldi r20,0x01
    out TIFR0,r20 ;TIFR ← 0b00000001</Code></pre>
</td>
<td></td>
</tr></table>

<p><b>Регистр TIMSK0</b> (Timer Interrupt Mask Register) – регистр масок прерываний.</p>

<div align="center"><img src="images/121.png" title="TIMSK0"></div>

<p>Прерывания разрешаются установкой соответствующих битов в регистре TIMSK0. Эти биты часто содержат в названии буквы IE: Interrupt Enable.
Например, OCIE – Output Compare Interrupt Enable.</p>

<p>Для разрешния прерывания Output Compare Interrupt 0 A:</p>

<table width="100%" cellspacing="0" cellpadding="4" border="0">
 <tr><td width="490"><pre><Code>      ldi r16,1 &lt&lt OCIE0A
      sts TIMSK0,r16 ;Enable timer output compare interrupt
      sei            ;Enable global interrupts</Code></pre>
</td>
<td></td>
</tr></table>

<p>При тактовой частоте F<sub>CLK</sub> 16 МГц и предделителе P<sub>Val</sub> на 1024 частота тактирования таймера-счётчика 16000000 / 1024 = 15625 Гц.
Тогда длительность периода (тика) 1 / 15625 = 0,000064 с.. Минимальная частота, которую способен сгенерировать Timer0 16000000 / 1024 / 256 =
61,03515625 Гц. Максимальный интервал времени, который может сформировать Timer0 – 1 / (15625 / 256) 0,016384 с.; Timer1 – 0,000064 с. * FFFFH =
4,194304 c. Продемонстрировать работу таймера можно на примере генерации звуковых сигналов. Напишем программу выдающую сигнал частотой 1000 Гц на
звуковой динамик, подключенный к линии 2 порта C. При этом длительность импульса равна длительности паузы (меандр). Частота микроконтроллера – 16
МГц. Организуем задержку с помощью таймера T0 в режиме Normal (по переполнению счётного регистра) в режиме с прерываниями.

<p>При тактовой частоте 16 МГц длительность импульса, как и длительность паузы сигнала должна продолжаться 8000 тактов. Тогда период сигнала будет
продолжительностью 16000 тактов, т.е. 1 / 1000 секунды. Это соответствует частоте повторений импульсов 1000 Гц. Задержка в цикле от одного
выполнения out PORTC, r18 до следующего его выполнения составит 16 000 тактов. Погрешность составит 0%.</p>

<table width="100%" cellspacing="0" cellpadding="4" border="0">
 <tr><td width="490"><pre><Code>.include "m328pdef.inc"

.org 0x0000 jmp Reset       ;Reset
.org 0x0020 jmp TIMER0_OVF  ;Переполнение таймера/счётчика 0
.org INT_VECTORS_SIZE       ;Конец таблицы прерываний

TIMER0_OVF:
      inc r19               ;Счётчик прерываний++
      out TCNT0, r17        ;Перезагрузить счётный регистр
      reti                  ;Возврат прерываний

Reset:
      ldi r16, Low(RAMEND)  ;Старт программы
      out SPL, r16          ;Обязательная инициализация стека
      ldi r16, High(RAMEND) ;Указатель стека - на конец ОЗУ
      out SPH, r16
;           7     6     5     4     3     2     1     0
;TIMSK0 =                               OCIEB OCIEA  TOIE
;TCCR0B = FOC0A FOC0B            WGM02  CS02  CS01  CS00
      ldi r16, 0b00000101
      out TCCR0B, r16       ;Предделитель на Clk/1024
;           7     6     5     4     3     2     1     0
;TIMSK0 =                               OCIEB OCIEA  TOIE
      ldi r16, 0b00000001
      sts TIMSK0, r16  ;Локальное разрешение прерывания для TIMER0
      ldi r17, 0x7
      out TCNT0, r17   ;Таймер - на 250 тика
      ldi r16, 0b00000100
      out DDRC, r16   ;Настройка на вывод линии 2 порта C
      sei             ;Разрешение прерываний

loop: cpi r19, 4      ;Пропустить 4 прерывания
      brne cycle
      nop             ;Ничего не делаем один такт
      eor r18, r16
      out PORTC, r18  ;Вывод инверсного состояния на линию 2 PortC
      clr r19
      rjmp loop</Code></pre>
</td>
<td></td>
</tr></table>

<p>Использование таймера для организации временной задержки оправдано лишь в простых случаях, так как останавливает весь поток вычислений для
обслуживания единственного устройства, не давая возможности выполнения других процессов, связанных с управлением. Поэтому для задач, где требуется
независимое обслуживание нескольких устройств с разным временем задержек, целесообразно использовать один таймер, настроенный на минимальный кратный
всем задержкам, период времени. Для удобства, за этот период принимают одну миллисекунду. Идея состоит в том, что один из таймеров с максимально
возможной точностью настраивается на генерацию прерываний каждую миллисекунду, а у каждого устройства управления имеется свой счётчик, который
«знает», сколько миллисекунд (прерываний) нужно отсчитывать, чтобы включать либо выключать устройство. Все счётчики включены в общий цикл, а таймер
каждую миллисекунду их оповещает о наступлении этого события. Такой механизм называется программным таймером. Это инструмент, позволяющий
организовать выполнение подпрограммы в точно заданные моменты времени.</p>

<p>Пример программы, реализующий такой подход, приведён ниже. В нём показано независимое управление тремя линиями порта, которые меняют своё
состояние каждые 200, 100 и 150 мс.. Наступление события выдержки одной миллисекунды сопровождается поднятием флага «Flag1ms». Если в этом цикле
прохода по счётчикам count1: – count3: какой-либо из них досчитал до нужного значения, то вызывается соответствующая функция управления устройством
count_n. В этом примере используется Timer0 в режиме Normal с предделителем на 64.</p>

<table width="100%" cellspacing="0" cellpadding="4" border="0">
 <tr><td width="490"><pre><Code>.include "m328pdef.inc"
.def temp = r16
.def Chan_1 = r17
.def Chan_2 = r18
.def Chan_3 = r19
.def Flag1ms = r20
.def count_1 = r21
.def count_2 = r22
.def count_3 = r23

	.cseg
	.org 0x0000 jmp Reset      ;Reset
	.org 0x0020 jmp TIMER0_OVF ;Переполнение таймера/счётчика 0
	.org INT_VECTORS_SIZE      ;Конец таблицы прерываний

Reset: ldi temp,High(RAMEND)   ;Старт программы
       out SPH,temp            ;Обязательная инициализация стека
       ldi temp,Low(RAMEND)    ;Указатель стека - на конец ОЗУ
       out SPL,temp

;настройка маски прерывания TIMSK0. В ней нужен бит TOIE
;           7     6     5     4     3     2     1     0
;TIMSK0 =                               OCIEB OCIEA  TOIE
       ldi temp, 0b00000001
       sts 0x006E, temp    ;Локальное разрешение прерывания Timer0
       ldi r30, 0x06       ;Таймер на 250 тиков
       out TCNT0, r30      ;Считаем от 6 до 255, т.е. 250, 1 такт
                           ;на сброс TCNT0

;          7     6     5     4     3     2     1     0
;TCCR0B = FOC0A FOC0B            WGM02  CS02  CS01  CS00
       ldi temp, 0b00000011
       out TCCR0B, temp        ;Предделитель на Clk/64
       ldi temp, 0b00000010
       out DDRB, temp          ;Port B, линия 1 - выход

;           7     6     5     4     3     2     1     0
;TIMSK0 =              ICIE             OCIEB OCIEA  TOIE

       ldi temp,0b00001111   ;PortB, линии 4..0 - выходы
       out DDRB,temp

       ldi Chan_1,0b00001000 ;Рабочие регистры
       ldi Chan_2,0b00000100
       ldi Chan_3,0b00000001
       sei                   ;Глобальное разрешение прерываний

main:  cpi Flag1ms,1   ;Если 1ms прошла... (Flag1ms = 1)
       breq count1     ;Оповещаем об этом все счётчики
       rjmp main       ;Главный цикл программы

count1:inc count_1
       cpi count_1,0xC8 ;Если счётчик 1 200 - переход в Ch1
       breq Ch1

count2:inc count_2
       cpi count_2,0x64 ;Если счётчик 2 100 - переход в Ch2
       breq Ch2

count3:inc count_3
       cpi count_3,0x96 ;Если счётчик 3 150 - переход в Ch3
       breq Ch3

CLR_Flag1ms:             ;Опустить Flag1ms после оповещения всех
       clr Flag1ms       ;счётчиков
       rjmp main

Ch1:   eor r24,Chan_1    ;Управление каналом 1, в r24 лежит 0
       out PORTB,r24     ;200мсек
       clr count_1
       rjmp count2

Ch2:   eor r24,Chan_2    ;Управление каналом 2
        out PORTB,r24    ;100мсек
       clr count_2
       rjmp count3

Ch3:   eor r24,Chan_3    ;Управление каналом 3
       out PORTB,r24     ;150мсек
       clr count_3
       rjmp CLR_Flag1ms

TIMER0_OVF:            ;Обработчик прерывания на 1мс
       ldi Flag1ms,1   ;Flag1ms
       out TCNT0, r30  ;Перезапуск таймера на 250 тиков
       reti            ;Возврат из прерывания в main</Code></pre>
</td>
<td></td>
</tr></table>

<p>В данном примере минимальный кратный период времени для всех счётчиков составляет 50 мс, поэтому самым оптимальным решением была бы настройка
таймера именно на это значение. Однако одна миллисекунда более удобна для адаптации этого примера под реальные задачи.</p>

<p>Необходимо отметить, что показанный пример вполне годится для случаев, когда все процессы по управлению устройствами гарантированно укладываются
в минимальный кратный период времени. И хотя современные микроконтроллеры имеют внушительную производительность, начиная с 20×10<sup>6</sup>
операций в секунду (20 MIPS) у самых простых AVR ATtiny с 6 выводами, даже такие устройства редко используют только для опроса состояния кнопок,
только для передачи команды по I<sup>2</sup>C-интерфейсу или только для включения обмотки электродвигателя. Гораздо чаще из МК пытаются «выжать»
всё, на что он способен, а в микроконтроллерное устройство заложить все возможные функции. Количество таких функций-задач, одновременно выполняемых
МК, может доходить до нескольких десятков что может быть довольно затруднительно.</p>

<p>Как организовать мультизадачность и поочерёдное выполнение каждой задачи? Как обеспечить запуск задачи через строго определённые интервалы
времени? Как передать информацию от одной задачи другой? Обычно эти вопросы не встают в начале разработки, а появляются позднее, когда требуется
согласовать и отладить параллельную работу множества устройств. Кроме того, необходимо учитывать, что МК работает в режиме реального времени, то
есть время реакции устройства на внешнее воздействие должно быть строго меньше заданной величины и должно быть сопоставимо со скоростью протекания
внешних процессов.</p>

<p>Такие проблемы хорошо решаются уже при использовании операционных систем реального времени (ОСРВ). Перечислим их отличительные возможности:</p>

<ul>
  <li>1. Многозадачность. ОСРВ предоставляет программисту готовый, отла-женный механизм многозадачности. Теперь каждую отдельную задачу можно
   программировать по отдельности так, как будто остальных задач не существует. Например, можно разработать архитектуру программы, то есть разбить
   её на отдельные задачи и распределить их между командой программистов. Программисту не нужно заботиться о переключении между задачами: за него
   это сделает ОСРВ в соответствии с алгоритмом работы планировщика.</li>
  <li>2. Временная база. Любая ОСРВ имеет удобный программный интерфейс для отсчёта интервалов времени и выполнения каких-либо действий в
   определённые моменты времени.</li>
  <li>3. Обмен данными между задачами. Можно передать информацию от одной задачи к другой без потерь, для чего используется очередь, которая
   гарантирует, что сообщения дойдут до адресата в том объёме и в той последовательности, в которой были отправлены.</li>
  <li>4. Синхронизация. Семафоры или сигналы для синхронизации позволяют выполнять задачи в строгой последовательности или по наступлении
   определённого события. Для организации совместного доступа разных задач к одному и тому же аппаратному ресурсу существует механизм мьютексов или
   критических секций.</li>
</ul>

<p>Подводя итог можно сказать, применение аппаратных таймеров оправдано в случаях, когда к точности отмеряемых временных интервалов предъявляется
высокие требования, так как активность других задач в программе может существенно повлиять на точность работы программных таймеров. Кроме того,
немаловажным ограничением является дискретность работы таймеров величиной в один системный квант времени.</p>

                        </td>
                    </tr>
                </table>
        <tr>

            <td colspan="2">

                <table border=0 cellspacing=0 cellpadding=0>
                    <tr>
                        <td background=../Оболочка/images/bg1.gif width=458 height=100 valign=Bottom>
                            <p class=co>Copyright &copy; БГУИР, Кафедра Систем управления, 2023<br><img
                                    src=../Оболочка/images/raspor.gif width=1 height=8></p></td>
                        <td background=../Оболочка/images/bg2.gif width=159 height=100>
                            <a href=#top onMouseOver="mOver(7)" onMouseOut="mOut(7)"><img src=../Оболочка/images/07a.gif
                                                                                          width=159 height=46 border=0
                                                                                          alt="К началу документа"
                                                                                          name="link7"></a><br>
                            <a href=../index.html onMouseOver="mOver(8)" onMouseOut="mOut(8)"><img
                                    src=../Оболочка/images/08a.gif width=159 height=54 border=0 alt="К первой странице"
                                    name="link8"></a></td>
                    </tr>
                </table>

            </td>
        </tr>


    </table>
</div>
</body>
</html>
